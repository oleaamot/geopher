.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Date::Manip::DM6 3"
.TH Date::Manip::DM6 3 "2022-06-01" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::DM6 \- Date manipulation routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use Date::Manip;
\&
\&   $version = DateManipVersion($flag);
\&
\&   Date_Init("VAR=VAL","VAR=VAL",...);
\&
\&   $date = ParseDate(\e@args [,@opts]);
\&   $date = ParseDate($string [,@opts]);
\&   $date = ParseDate(\e$string [,@opts]);
\&
\&   $date = ParseDateString($string [,@opts]);
\&
\&   $date = ParseDateFormat($format,$string);
\&
\&   @date = UnixDate($date,@format);
\&   $date = UnixDate($date,@format);
\&
\&   $delta = ParseDateDelta(\e@args   [,$mode]);
\&   $delta = ParseDateDelta($string  [,$mode]);
\&   $delta = ParseDateDelta(\e$string [,$mode]);
\&
\&   @str = Delta_Format($delta, [$mode,] $dec,@format);
\&   $str = Delta_Format($delta, [$mode,] $dec,@format);
\&
\&   $recur = ParseRecur($string,$base,$date0,$date1,$flags);
\&   @dates = ParseRecur($string,$base,$date0,$date1,$flags);
\&
\&   $flag = Date_Cmp($date1,$date2);
\&
\&   $d = DateCalc($d1,$d2 [,$errref] [,$mode]);
\&
\&   $date = Date_SetTime($date,$hr,$min,$sec);
\&   $date = Date_SetTime($date,$time);
\&
\&   $date = Date_SetDateField($date,$field,$val [,$nocheck]);
\&
\&   $date = Date_GetPrev($date,$dow,$today,$hr,$min,$sec);
\&   $date = Date_GetPrev($date,$dow,$today,$time);
\&
\&   $date = Date_GetNext($date,$dow,$today,$hr,$min,$sec);
\&   $date = Date_GetNext($date,$dow,$today,$time);
\&
\&   $name = Date_IsHoliday($date);
\&   @name = Date_IsHoliday($date);
\&
\&   $listref = Events_List($date);
\&   $listref = Events_List($date0,$date1);
\&
\&   $date = Date_ConvTZ($date,$from,$to);
\&
\&   $flag = Date_IsWorkDay($date [,$flag]);
\&
\&   $date = Date_NextWorkDay($date,$off [,$time]);
\&
\&   $date = Date_PrevWorkDay($date,$off [,$time]);
\&
\&   $date = Date_NearestWorkDay($date [,$tomorrowfirst]);
.Ve
.PP
In the following routines, \f(CW$y\fR may be entered as either a 2 or 4 digit
year (it will be converted to a 4 digit year based on the variable
YYtoYYYY described below).  Month and day should be numeric in all
cases.
.PP
.Vb 12
\&   $day = Date_DayOfWeek($m,$d,$y);
\&   $secs = Date_SecsSince1970($m,$d,$y,$h,$mn,$s);
\&   $secs = Date_SecsSince1970GMT($m,$d,$y,$h,$mn,$s);
\&   $days = Date_DaysSince1BC($m,$d,$y);
\&   $day = Date_DayOfYear($m,$d,$y);
\&   ($y,$m,$d,$h,$mn,$s) = Date_NthDayOfYear($y,$n);
\&   $days = Date_DaysInYear($y);
\&   $days = Date_DaysInMonth($m,$y);
\&   $wkno = Date_WeekOfYear($m,$d,$y,$first);
\&   $flag = Date_LeapYear($y);
\&   $day = Date_DaySuffix($d);
\&   $tz = Date_TimeZone();
.Ve
.SH "ROUTINES"
.IX Header "ROUTINES"
.IP "\fBDateManipVersion\fR" 4
.IX Item "DateManipVersion"
.Vb 1
\&   $version = DateManipVersion($flag);
.Ve
.Sp
Returns the version of Date::Manip.  If \f(CW$flag\fR is non-zero, timezone information
is also returned.
.IP "\fBDate_Init\fR" 4
.IX Item "Date_Init"
.Vb 1
\&   Date_Init("VAR=VAL","VAR=VAL",...);
.Ve
.Sp
The Date_Init function is used to set any of the Date::Manip configuration
variables described in the Date::Manip::Config document.
.Sp
The strings to pass in are of the form \*(L"VAR=VAL\*(R".  Any number may be
included and they can come in any order.  \s-1VAR\s0 may be any configuration
variable.  \s-1VAL\s0 is any allowed value for that variable.  For example,
to switch from English to French and use non-US format (so that 12/10
is Oct 12), do the following:
.Sp
.Vb 1
\&   Date_Init("Language=French","DateFormat=non\-US");
.Ve
.Sp
Note that variables are parsed in the order they are given, so
\&\*(L"DateFormat=non\-US\*(R", \*(L"ConfigFile=./manip.cnf\*(R" may not give the
expected result. To be safe, ConfigFile should always appear first in
the list.
.IP "\fBParseDate\fR" 4
.IX Item "ParseDate"
.Vb 3
\&   $date = ParseDate(\e@args [,@opts]);
\&   $date = ParseDate($string [,@opts]);
\&   $date = ParseDate(\e$string [,@opts]);
.Ve
.Sp
This takes an array or a string containing a date and parses it.  When the
date is included as an array (for example, the arguments to a program) the
array should contain a valid date in the first one or more elements
(elements after a valid date are ignored).  Elements containing a valid
date are shifted from the array.  The largest possible number of elements
which can be correctly interpreted as a valid date are always used.  If a
string is entered rather than an array, that string is tested for a valid
date.  The string is unmodified, even if passed in by reference.
.Sp
The ParseDate routine is primarily used to handle command line arguments.
If you have a command where you want to enter a date as a command line
argument, you can use Date::Manip to make something like the following
work:
.Sp
.Vb 1
\&   mycommand \-date Dec 10 1997 \-arg \-arg2
.Ve
.Sp
No more reading man pages to find out what date format is required in a
man page.
.Sp
The \f(CW@opts\fR argument may contain values that can be passed to the
\&\f(CW\*(C`Date::Manip::Date::parse\*(C'\fR method.
.Sp
Historical note: this is originally why the Date::Manip routines were
written (though long before they were released as the Date::Manip module).
I was using a bunch of programs (primarily batch queue managers) where
dates and times were entered as command line options and I was getting
highly annoyed at the many different (but not compatible) ways that they
had to be entered.  Date::Manip originally consisted of basically 1 routine
which I could pass \*(L"@ARGV\*(R" to and have it remove a date from the beginning.
.IP "\fBParseDateString\fR" 4
.IX Item "ParseDateString"
.Vb 1
\&   $date = ParseDateString($string [,@opts]);
.Ve
.Sp
This parses a string containing a date and returns it. Refer to the
Date::Manip::Date documentation for valid date formats. The date
returned is in the local time zone.
.Sp
The \f(CW@opts\fR argument may contain values that can be passed to the
\&\f(CW\*(C`Date::Manip::Date::parse\*(C'\fR method.
.IP "\fBParseDateFormat\fR" 4
.IX Item "ParseDateFormat"
.Vb 1
\&   $date = ParseDateFormat($format,$string);
.Ve
.Sp
This parses a string containing a date based on a format string and
returns the date. Refer to the Date::Manip::Date documentation for the
parse_format method for more information. The date returned is in the
local time zone.
.IP "\fBUnixDate\fR" 4
.IX Item "UnixDate"
.Vb 2
\&   $out = UnixDate($date,$in);
\&   @out = UnixDate($date,@in);
.Ve
.Sp
This takes a date and a list of strings containing formats roughly
identical to the format strings used by the \s-1UNIX\s0 \fBdate\fR\|(1) command.
Each format is parsed and an array of strings corresponding to each
format is returned.
.Sp
The formats are described in the Date::Manip::Date document.
.IP "\fBParseDateDelta\fR" 4
.IX Item "ParseDateDelta"
.Vb 3
\&   $delta = ParseDateDelta(\e@args   [,$mode]);
\&   $delta = ParseDateDelta($string  [,$mode]);
\&   $delta = ParseDateDelta(\e$string [,$mode]);
.Ve
.Sp
In the first form, it takes an array and shifts a valid delta from it.
In the other two forms, it parses a string to see if it contains a
valid delta.
.Sp
A valid delta is returned if found. Otherwise, an empty string is
returned.
.Sp
The delta can be converted to 'exact', 'semi', or 'approx' using the
Date::Manip::Delta::convert method if \f(CW$mode\fR is passed in.
.IP "\fBDelta_Format\fR" 4
.IX Item "Delta_Format"
.Vb 2
\&   $out = Delta_Format($delta [,$mode], $dec,$in);
\&   @out = Delta_Format($delta [,$mode], $dec,@in);
.Ve
.Sp
This is similar to the UnixDate routine except that it extracts information
from a delta.
.Sp
When formatting fields in a delta, the Date::Manip 6.00 formats have changed
and are much more powerful. The old 5.xx formats are still available for
the Delta_Format command for backward compatibility. These formats include:
.Sp
.Vb 1
\&   %Xv  : print the value of the field X
\&
\&   %Xd  : print the value of the field X and all
\&          smaller units in terms of X
\&
\&   %Xh  : print the value of field X and all
\&          larger units in terms of X
\&
\&   %Xt  : print the value of all fields in
\&          terms of X
.Ve
.Sp
These make use of the \f(CW$mode\fR and \f(CW$dec\fR arguments to determine how to
format the information.
.Sp
\&\f(CW$dec\fR is an integer, and is required, It tells the number of decimal
places to use.
.Sp
\&\f(CW$mode\fR is either \*(L"exact\*(R", \*(L"semi\*(R", or \*(L"approx\*(R" and defaults to \*(L"exact\*(R"
if it is not included.
.Sp
In \*(L"exact\*(R" mode, only exact relationships are used.  This means that
there can be no mixing of the Y/M, W/D, and H/MN/S segments (for
non-business deltas, or Y/M, W, and D/H/MN/S segments for business
deltas) because there is no exact relation between the fields of each
set.
.Sp
In \*(L"semi\*(R" mode, the semi-approximate relationships are used so
there is no mixing between Y/M and W/D/H/MN/S.
.Sp
In \*(L"approx\*(R" mode, approximate relationships are used so all fields
can mix.
.Sp
The semi-approximate and approximate relationships are described in
the Date::Manip::Delta manual.
.Sp
So, in \*(L"exact\*(R" mode, with a non-business delta, and \f(CW$dec\fR = 2, the
following are equivalent:
.Sp
.Vb 7
\&   old style    new style
\&   \-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-
\&   %Xv          %Xv
\&   %hd          %.2hhs
\&   %hh          %.2hdh
\&   %ht          %.2hds
\&   %yd          %.2yyM
.Ve
.Sp
In \*(L"approximate\*(R" mode, the following are equivalent:
.Sp
.Vb 7
\&   old style    new style
\&   \-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-
\&   %Xv          %Xv
\&   %hd          %.2hhs
\&   %hh          %.2hdh
\&   %ht          %.2hys
\&   %yd          %.2yys
.Ve
.Sp
If you want to use the new style formats in Delta_Format, use one of
the calls:
.Sp
.Vb 2
\&   Delta_Format($delta, @in);
\&   Delta_Format($delta, undef, @in);
.Ve
.Sp
If the first element of \f(CW@in\fR is an integer, you have to use the 2nd
form.
.Sp
The old formats will remain available for the time being, though at
some point they may be deprecated.
.IP "\fBDateCalc\fR" 4
.IX Item "DateCalc"
.Vb 1
\& $d = DateCalc($d1,$d2 [,\e$err] [,$mode]);
.Ve
.Sp
This takes two dates, deltas, or one of each and performs the appropriate
calculation with them.  Dates must be a string that can be parsed by
ParseDateString.  Deltas must be a string that can be parsed by
ParseDateDelta.  Two deltas add together to form a third delta.  A date
and a delta returns a 2nd date.  Two dates return a delta (the difference
between the two dates).
.Sp
Since the two items can be interpreted as either dates or deltas, and
since many strings can be interpreted as both a date or a delta, it
is a good idea to pass the input through ParseDateDelta,
if appropriate if there is any ambiguity. For example, the string
\&\*(L"09:00:00\*(R" can be interpreted either as a date (today at 9:00:00) or a
delta (9 hours). To avoid unexpected results, avoid calling DateCalc
as:
.Sp
.Vb 1
\&  $d = DateCalc("09:00:00",$someothervalue);
.Ve
.Sp
Instead, call it as:
.Sp
.Vb 1
\&  $d = DateCalc(ParseDate("09:00:00"),$someothervalue);
.Ve
.Sp
to force it to be a date, or:
.Sp
.Vb 1
\&  $d = DateCalc(ParseDateDelta("09:00:00"),$someothervalue);
.Ve
.Sp
to force it to be a delta. This will avoid unexpected results.
Passing something through ParseDate is optional since they will be
treated as dates by default (and for performance reasons, you're
better off not calling ParseDate).
.Sp
If there is no ambiguity, you are better off \s-1NOT\s0 doing this for
performance reasons. If the delta is a business delta, you definitely
should \s-1NOT\s0 do this.
.Sp
One other thing to note is that when parsing dates, a delta can
be interpreted as a date relative to now. DateCalc will \s-1ALWAYS\s0
treat a delta as a delta, \s-1NOT\s0 a date.
.Sp
For details on how calculations are done, refer to the Date::Manip::Calc
documentation.
.Sp
By default, math is done using an exact mode.
.Sp
If two deltas, or a date and a delta are passed in, \f(CW$mode\fR may be used
to force the delta to be either business or non-business mode deltas.
If \f(CW$mode\fR is 0 or 1, the delta(s) will be non-business. Otherwise,
they will be business deltas. If \f(CW$mode\fR is passed in, it will be used
only if the business or non-business state was not explicitly set in
the delta.  \f(CW$mode\fR can also be any of the modes discussed in
the Date::Manip::Calc documentation.
.Sp
If two dates are passed in, \f(CW$mode\fR is used to determine the type of
calculation.  By default, an exact delta is produced.  If \f(CW$mode\fR is 1,
an approximate delta is produced.  If \f(CW$mode\fR is 2, a business
approximate (bapprox) mode calculation is done.  If \f(CW$mode\fR is 3, a
exact business mode delta is produced.
.Sp
If \e$err is passed in, it is set to:
.Sp
.Vb 3
\&   1 is returned if $d1 is not a delta or date
\&   2 is returned if $d2 is not a delta or date
\&   3 if any other error occurs.
.Ve
.Sp
This argument is optional, but if included, it must come before \f(CW$mode\fR.
.Sp
Nothing is returned if an error occurs.
.IP "\fBParseRecur\fR" 4
.IX Item "ParseRecur"
.Vb 2
\&   $recur = ParseRecur($string [,$base,$date0,$date1,$flags]);
\&   @dates = ParseRecur($string [,$base,$date0,$date1,$flags]);
.Ve
.Sp
This parses a string containing a recurrence and returns a fully specified
recurrence, or a list of dates referred to.
.Sp
\&\f(CW$string\fR can be any of the forms:
.Sp
.Vb 5
\&   FREQ
\&   FREQ*FLAGS
\&   FREQ*FLAGS*BASE
\&   FREQ*FLAGS*BASE*DATE0
\&   FREQ*FLAGS*BASE*DATE0*DATE1
.Ve
.Sp
where \s-1FREQ\s0 is a frequence (see the Date::Manip::Delta documentation),
\&\s-1FLAGS\s0 is a comma separated list of flags, and \s-1BASE, DATE0,\s0 and \s-1DATE1\s0 are
date strings. The dates and flags can also be passed in as \f(CW$base\fR, \f(CW$date0\fR,
\&\f(CW$date1\fR, and \f(CW$flags\fR, and these will override any values in \f(CW$string\fR.
.Sp
In scalar context, the fully specified recurrence (or as much information
as is available) will be returned. In list context, a list of dates will
be returned.
.IP "\fBDate_Cmp\fR" 4
.IX Item "Date_Cmp"
.Vb 1
\&   $flag = Date_Cmp($date1,$date2);
.Ve
.Sp
This takes two dates and compares them. Any dates that can be parsed will be
compared.
.IP "\fBDate_GetPrev\fR" 4
.IX Item "Date_GetPrev"
.Vb 4
\&   $date = Date_GetPrev($date,$dow, $curr [,$hr,$min,$sec]);
\&   $date = Date_GetPrev($date,$dow, $curr [,$time]);
\&   $date = Date_GetPrev($date,undef,$curr,$hr,$min,$sec);
\&   $date = Date_GetPrev($date,undef,$curr,$time);
.Ve
.Sp
This takes a date (any string that may be parsed by ParseDateString) and finds
the previous occurrence of either a day of the week, or a certain time of day.
.Sp
This is documented in the \*(L"prev\*(R" method in Date::Manip::Date, except that
here, \f(CW$time\fR is a string (\s-1HH, HH:MN:,\s0 or \s-1HH:MN:SS\s0), and \f(CW$dow\fR may be a string
of the form \*(L"Fri\*(R" or \*(L"Friday\*(R".
.IP "\fBDate_GetNext\fR" 4
.IX Item "Date_GetNext"
.Vb 4
\&   $date = Date_GetNext($date,$dow, $curr [,$hr,$min,$sec]);
\&   $date = Date_GetNext($date,$dow, $curr [,$time]);
\&   $date = Date_GetNext($date,undef,$curr,$hr,$min,$sec);
\&   $date = Date_GetNext($date,undef,$curr,$time);
.Ve
.Sp
Similar to Date_GetPrev.
.IP "\fBDate_SetTime\fR" 4
.IX Item "Date_SetTime"
.Vb 2
\&   $date = Date_SetTime($date,$hr,$min,$sec);
\&   $date = Date_SetTime($date,$time);
.Ve
.Sp
This takes a date (any string that may be parsed by ParseDateString) and
sets the time in that date.  For example, one way to get the time for 7:30
tomorrow would be to use the lines:
.Sp
.Vb 2
\&   $date = ParseDate("tomorrow");
\&   $date = Date_SetTime($date,"7:30");
.Ve
.Sp
\&\f(CW$time\fR is a string (\s-1HH, HH:MN,\s0 or \s-1HH:MN:SS\s0).
.IP "\fBDate_SetDateField\fR" 4
.IX Item "Date_SetDateField"
.Vb 1
\&   $date = Date_SetDateField($date,$field,$val);
.Ve
.Sp
This takes a date and sets one of its fields to a new value.  \f(CW$field\fR is
any of the strings \*(L"y\*(R", \*(L"m\*(R", \*(L"d\*(R", \*(L"h\*(R", \*(L"mn\*(R", \*(L"s\*(R" (case insensitive) and
\&\f(CW$val\fR is the new value.
.IP "\fBDate_IsHoliday\fR" 4
.IX Item "Date_IsHoliday"
.Vb 2
\&   $name = Date_IsHoliday($date);
\&   @name = Date_IsHoliday($date);
.Ve
.Sp
This returns undef if \f(CW$date\fR is not a holiday, or a string containing
the name of the holiday otherwise (or a list of names in list
context).  An empty string is returned for an unnamed holiday.
.IP "\fBDate_IsWorkDay\fR" 4
.IX Item "Date_IsWorkDay"
.Vb 1
\&   $flag = Date_IsWorkDay($date [,$flag]);
.Ve
.Sp
This returns 1 if \f(CW$date\fR is a work day.  If \f(CW$flag\fR is non-zero, the time is
checked to see if it falls within work hours.  It returns an empty string
if \f(CW$date\fR is not valid.
.IP "\fBEvents_List\fR" 4
.IX Item "Events_List"
.Vb 3
\&   $ref = Events_List($date);
\&   $ref = Events_List($date,0      [,$flag]);
\&   $ref = Events_List($date,$date1 [,$flag]);
.Ve
.Sp
This returns a list of events. If \f(CW$flag\fR is not given, or is equal to 0,
the list (returned as a reference) is similar to the the list returned
by the Date::Manip::Date::list_events method with \f(CW$format\fR = \*(L"dates\*(R".
The only difference is that it is formatted slightly different to be
backward compatible with Date::Manip 5.xx.
.Sp
The data from the list_events method is:
.Sp
.Vb 4
\&   ( [DATE1, NAME1a, NAME1b, ...],
\&     [DATE2, NAME2a, NAME2b, ...],
\&     ...
\&   )
.Ve
.Sp
The reference returned from Events_List (if \f(CW$flag\fR = 0) is:
.Sp
.Vb 4
\&   [ DATE1, [NAME1a, NAME1b, ...],
\&     DATE2, [DATE2a, DATE2b, ...],
\&     ...
\&   ]
.Ve
.Sp
For example, if the following events are defined:
.Sp
.Vb 5
\&  2000\-01\-01 ; 2000\-03\-21  = Winter
\&  2000\-03\-22 ; 2000\-06\-21  = Spring
\&  2000\-02\-01               = Event1
\&  2000\-05\-01               = Event2
\&  2000\-04\-01\-12:00:00      = Event3
.Ve
.Sp
the following examples illustrate the function:
.Sp
.Vb 2
\&  Events_List("2000\-04\-01")
\&   => [ 2000040100:00:00, [ Spring ] ]
\&
\&  Events_List("2000\-04\-01 12:30");
\&   => [ 2000040112:30:00, [ Spring, Event3 ] ]
\&
\&  Events_List("2000\-04\-01",0);
\&   => [ 2000040100:00:00, [ Spring ],
\&        2000040112:00:00, [ Spring, Event3 ],
\&        2000040113:00:00, [ Spring ] ]
\&
\&  Events_List("2000\-03\-15","2000\-04\-10");
\&   => [ 2000031500:00:00, [ Winter ],
\&        2000032200:00:00, [ Spring ]
\&        2000040112:00:00, [ Spring, Event3 ]
\&        2000040113:00:00, [ Spring ] ]
.Ve
.Sp
If \f(CW$flag\fR is 1, then a tally of the amount of time given to each event
is returned.  Time for which two or more events apply is counted for
both.
.Sp
.Vb 5
\&  Events_List("2000\-03\-15","2000\-04\-10",1);
\&   => { Event3 => +0:0:+0:0:1:0:0,
\&        Spring => +0:0:+2:4:23:0:0,
\&        Winter => +0:0:+1:0:0:0:0
\&      }
.Ve
.Sp
When \f(CW$flag\fR is 2, a more complex tally with no event counted twice is
returned.
.Sp
.Vb 5
\&  Events_List("2000\-03\-15","2000\-04\-10",2);
\&   => { Event3+Spring => +0:0:+0:0:1:0:0,
\&        Spring        => +0:0:+2:4:22:0:0,
\&        Winter        => +0:0:+1:0:0:0:0
\&      }
.Ve
.Sp
The hash contains one element for each combination of events.
.Sp
In both of these cases, there may be a hash element with an empty
string as the key which contains the amount of time with no events
active.
.IP "\fBDate_DayOfWeek\fR" 4
.IX Item "Date_DayOfWeek"
.Vb 1
\&   $day = Date_DayOfWeek($m,$d,$y);
.Ve
.Sp
Returns the day of the week (1 for Monday, 7 for Sunday).
.IP "\fBDate_SecsSince1970\fR" 4
.IX Item "Date_SecsSince1970"
.Vb 1
\&   $secs = Date_SecsSince1970($m,$d,$y,$h,$mn,$s);
.Ve
.Sp
Returns the number of seconds since Jan 1, 1970 00:00 (negative if date is
earlier) in the current timezone.
.IP "\fBDate_SecsSince1970GMT\fR" 4
.IX Item "Date_SecsSince1970GMT"
.Vb 1
\&   $secs = Date_SecsSince1970GMT($m,$d,$y,$h,$mn,$s);
.Ve
.Sp
Returns the number of seconds since Jan 1, 1970 00:00 \s-1GMT\s0 (negative if date
is earlier).  Note that the date is still given in the current timezone, \s-1NOT
GMT.\s0
.IP "\fBDate_DaysSince1BC\fR" 4
.IX Item "Date_DaysSince1BC"
.Vb 1
\&   $days = Date_DaysSince1BC($m,$d,$y);
.Ve
.Sp
Returns the number of days since Dec 31, 1BC.  This includes the year 0001.
.IP "\fBDate_DayOfYear\fR" 4
.IX Item "Date_DayOfYear"
.Vb 1
\&   $day = Date_DayOfYear($m,$d,$y);
.Ve
.Sp
Returns the day of the year (1 to 366)
.IP "\fBDate_NthDayOfYear\fR" 4
.IX Item "Date_NthDayOfYear"
.Vb 1
\&   ($y,$m,$d,$h,$mn,$s) = Date_NthDayOfYear($y,$n);
.Ve
.Sp
Returns the year, month, day, hour, minutes, and decimal seconds given
a floating point day of the year.
.Sp
All arguments must be numeric.  \f(CW$n\fR must be greater than or equal to 1
and less than 366 on non-leap years and 367 on leap years.
.Sp
\&\s-1NOTE:\s0 When \f(CW$n\fR is a decimal number, the results are non-intuitive perhaps.
Day 1 is Jan 01 00:00.  Day 2 is Jan 02 00:00.  Intuitively, you
might think of day 1.5 as being 1.5 days after Jan 01 00:00, but this
would mean that Day 1.5 was Jan 02 12:00 (which is later than Day 2).
The best way to think of this function is a time line starting at 1 and
ending at 366 (in a non-leap year).  In terms of a delta, think of \f(CW$n\fR
as the number of days after Dec 31 00:00 of the previous year.
.IP "\fBDate_DaysInYear\fR" 4
.IX Item "Date_DaysInYear"
.Vb 1
\&   $days = Date_DaysInYear($y);
.Ve
.Sp
Returns the number of days in the year (365 or 366)
.IP "\fBDate_DaysInMonth\fR" 4
.IX Item "Date_DaysInMonth"
.Vb 1
\&   $days = Date_DaysInMonth($m,$y);
.Ve
.Sp
Returns the number of days in the month.
.IP "\fBDate_WeekOfYear\fR" 4
.IX Item "Date_WeekOfYear"
.Vb 1
\&   $wkno = Date_WeekOfYear($m,$d,$y,$first);
.Ve
.Sp
Figure out week number.  \f(CW$first\fR is the first day of the week which is
usually 1 (Monday) or 7 (Sunday), but could be any number between 1 and 7
in practice.
.Sp
\&\s-1NOTE:\s0 This routine should only be called in rare cases.  Use UnixDate with
the \f(CW%W\fR, \f(CW%U\fR, \f(CW%J\fR, \f(CW%L\fR formats instead.  This routine returns a week between 0
and 53 which must then be \*(L"fixed\*(R" to get into the \s-1ISO\-8601\s0 weeks from 1 to
53.  A date which returns a week of 0 actually belongs to the last week of
the previous year.  A date which returns a week of 53 may belong to the
first week of the next year.
.IP "\fBDate_LeapYear\fR" 4
.IX Item "Date_LeapYear"
.Vb 1
\&   $flag = Date_LeapYear($y);
.Ve
.Sp
Returns 1 if the argument is a leap year
Written by David Muir Sharnoff <muir@idiom.com>
.IP "\fBDate_DaySuffix\fR" 4
.IX Item "Date_DaySuffix"
.Vb 1
\&   $day = Date_DaySuffix($d);
.Ve
.Sp
Add `st', `nd', `rd', `th' to a date (i.e. 1st, 22nd, 29th).  Works for
international dates.
.IP "\fBDate_TimeZone\fR" 4
.IX Item "Date_TimeZone"
.Vb 1
\&   $tz = Date_TimeZone;
.Ve
.Sp
This determines and returns the local time zone.  If it is unable to determine
the local time zone, the following error occurs:
.Sp
.Vb 1
\&   ERROR: Date::Manip unable to determine Time Zone.
.Ve
.Sp
See the Date::Manip::TZ documentation (\s-1DETERMINING THE LOCAL TIME ZONE\s0) for
more information.
.IP "\fBDate_ConvTZ\fR" 4
.IX Item "Date_ConvTZ"
.Vb 1
\&   $date = Date_ConvTZ($date,$from,$to);
.Ve
.Sp
This converts a date (which \s-1MUST\s0 be in the format returned by ParseDate)
from one time zone to another.
.Sp
\&\f(CW$from\fR and \f(CW$to\fR each default to the local time zone. If they are given,
they must be any time zone or alias understood by Date::Manip.
.Sp
If an error occurs, an empty string is returned.
.IP "\fBDate_NextWorkDay\fR" 4
.IX Item "Date_NextWorkDay"
.Vb 1
\&   $date = Date_NextWorkDay($date,$off [,$time]);
.Ve
.Sp
Finds the day \f(CW$off\fR work days from now.  If \f(CW$time\fR is passed in, we must also
take into account the time of day.
.Sp
If \f(CW$time\fR is not passed in, day 0 is today (if today is a workday) or the
next work day if it isn't.  In any case, the time of day is unaffected.
.Sp
If \f(CW$time\fR is passed in, day 0 is now (if now is part of a workday) or the
start of the very next work day.
.IP "\fBDate_PrevWorkDay\fR" 4
.IX Item "Date_PrevWorkDay"
.Vb 1
\&   $date = Date_PrevWorkDay($date,$off [,$time]);
.Ve
.Sp
Similar to Date_NextWorkDay.
.IP "\fBDate_NearestWorkDay\fR" 4
.IX Item "Date_NearestWorkDay"
.Vb 1
\&   $date = Date_NearestWorkDay($date [,$tomorrowfirst]);
.Ve
.Sp
This looks for the work day nearest to \f(CW$date\fR.  If \f(CW$date\fR is a work day, it
is returned.  Otherwise, it will look forward or backwards in time 1 day
at a time until a work day is found.  If \f(CW$tomorrowfirst\fR is non-zero (or if
it is omitted and the config variable TomorrowFirst is non-zero), we look
to the future first.  Otherwise, we look in the past first.  In other words,
in a normal week, if \f(CW$date\fR is Wednesday, \f(CW$date\fR is returned.  If \f(CW$date\fR is
Saturday, Friday is returned.  If \f(CW$date\fR is Sunday, Monday is returned.  If
Wednesday is a holiday, Thursday is returned if \f(CW$tomorrowfirst\fR is non-nil
or Tuesday otherwise.
.PP
For all of the functions which return a date, the format of the returned
date is governed by the Printable config variable. If a date is returned,
it is in the local time zone, \s-1NOT\s0 the time zone the date was parsed in.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
