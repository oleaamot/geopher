.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Date::Manip::TZ 3"
.TH Date::Manip::TZ 3 "2022-06-01" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::TZ \- an interface to the time zone data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Date::Manip::TZ;
\&   $tz = new Date::Manip::TZ;
.Ve
.PP
Data for most (and hopefully all) time zones used around the world have
been gathered and is publicly available in the zoneinfo (or Olson)
database.
.PP
This module uses the data from the zoneinfo database to perform various
time zone operations.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Every time zone has some of the following characteristics:
.IP "\fBname\fR" 4
.IX Item "name"
Every time zone has a unique name. In the zoneinfo database, these
are something similar to:
.Sp
.Vb 1
\&   America/New_York
.Ve
.IP "\fBaliases\fR" 4
.IX Item "aliases"
Time zones may have (but are not required to have) one or more aliases.
Each alias is unique, and is not the same as any time zone name. An
alias can be used in exactly the same way as a name.
.IP "\fBperiods\fR" 4
.IX Item "periods"
Every time zone is broken up into periods. Each period describes how
a portion of time relates to \s-1GMT,\s0 and how it might be expressed.
.PP
Each period includes the following information:
.IP "\fBstart time, end time\fR" 4
.IX Item "start time, end time"
The period begin and ends at certain times. The times are
included both as an absolute \s-1GMT\s0 time, and as a wall clock time.
The wall clock start time is the time that will be on a clock
just as the period starts (i.e. after a time change). The wall clock
end time is the time on a clock immediately before the period ends.
.IP "\fBoffset\fR" 4
.IX Item "offset"
The entire period has an offset which is how much the wall clock
time differs from \s-1GMT.\s0
.IP "\fBabbreviation\fR" 4
.IX Item "abbreviation"
When expressing the time period, an abbreviation (such as \s-1EST\s0) is
typically used.
.IP "\fBdaylight saving time flag\fR" 4
.IX Item "daylight saving time flag"
Every period is categorized as a standard time or a daylight
saving time. The flag will be 1 if it is a daylight saving time,
or 0 if it is a standard time.
.PP
Date::Manip includes all of the data for all of the time zones from
the zoneinfo database. This data is available from:
.PP
<ftp://ftp.iana.org/tz/>
.PP
Additional data from other standards are also used.
.PP
The zoneinfo database is not necessary in order to use Date::Manip.
Instead, all of that data has been extracted and stored in a
series of other modules which are used to handle each time zone.
In that way, Date::Manip has no dependency on any other source
of data.
.PP
The Date::Manip::Zones document contains detailed information
on the data available.
.SH "METHODS"
.IX Header "METHODS"
In all methods, the following variables are used:
.IP "\fB\f(CB$zone\fB\fR" 4
.IX Item "$zone"
This is a string which contains a valid time zone name.  For
example:
.Sp
.Vb 1
\&  America/New_York
.Ve
.IP "\fB\f(CB$alias\fB\fR" 4
.IX Item "$alias"
This is a strings which contains a valid time zone name, or a valid
time zone alias. For example:
.Sp
.Vb 3
\&  America/New_York
\&  US/Eastern
\&  EST5EDT
.Ve
.IP "\fB\f(CB$abbrev\fB\fR" 4
.IX Item "$abbrev"
This is a string which contains a valid time zone abbreviation. For
example:
.Sp
.Vb 1
\&  EST
.Ve
.IP "\fB\f(CB$offset\fB\fR" 4
.IX Item "$offset"
This is a time zone entered as an offset. An offset is either a string
of one of the formats:
.Sp
.Vb 5
\&  +HH
\&  +HHMM
\&  +HHMMSS
\&  +HH:MM
\&  +HH:MM:SS
.Ve
.Sp
or it can be a list reference:
.Sp
.Vb 1
\&  [HH,MM,SS]
.Ve
.Sp
If a list reference is used, the sign must be included with all values.
So, the offset \*(L"\-05:30\*(R" would be the list reference:
.Sp
.Vb 1
\&  [\-5,\-30,0]
.Ve
.IP "\fB\f(CB$dstflag\fB\fR" 4
.IX Item "$dstflag"
This is always one of the values: std, stdonly, dst, dstonly
.Sp
It defaults to \*(L"std\*(R" if it is not present. When determining a time zone,
it is usually necessary to check a number of different time zone and
\&\s-1DST\s0 combinations.
.Sp
If \f(CW$dstflag\fR is \*(L"std\*(R", it will check both standard and daylight saving
times, but will give preference to standard times. If \f(CW$dstflag\fR is
\&\*(L"stdonly\*(R", only standard times will be checked.
.Sp
The \*(L"dst\*(R" flag will search both, but give preference to daylight saving
times.  The \*(L"dstonly\*(R" values will only use daylight saving times.
.IP "\fB\f(CB$date\fB\fR" 4
.IX Item "$date"
A date is always a string containing a date in one of the formats:
.Sp
.Vb 3
\&   YYYYMMDDHH:MN:SS
\&   YYYY\-MM\-DD\-HH:MN:SS
\&   YYYYMMDDHHMNSS
.Ve
.Sp
or a list reference:
.Sp
.Vb 1
\&   [Y,M,D,H,MN,S]
.Ve
.IP "\fB\f(CB$isdst\fB\fR" 4
.IX Item "$isdst"
This is 0 if a date is in standard time, 1 if it is in daylight saving
time.
.IP "\fB\f(CB$period\fB\fR" 4
.IX Item "$period"
A period is a list reference currently containing the following
items:
.Sp
.Vb 2
\&   [ $dateUT, $dateLT, $offsetstr, $offset, $abbrev, $isdst,
\&     $endUT, $endLT, $begUTs, $begLTs, $endUTs, $endLTs ]
.Ve
.Sp
\&\f(CW$dateUT\fR and \f(CW$dateLT\fR are the starting date of the period (i.e. the
first second in a period) in universal (\s-1GMT\s0) time and local
(wall clock) time. \f(CW$endUT\fR and \f(CW$endLT\fR are the end date of the period
(i.e. the last second in a period) in universal and local time.
These are all stored as list references.
.Sp
\&\f(CW$offsetstr\fR is the string representation of the offset (\*(L"+05:00:00\*(R")
and \f(CW$offset\fR is the corresponding list reference form ([5,0,0]).
.Sp
\&\f(CW$abbrev\fR is the abbreviation that applies during this period, and \f(CW$isdst\fR
is 0 or 1 if it is standard or daylight saving time.
.Sp
When accessing the elements in a period, use \s-1ONLY\s0 positive indices.
In other words, to get \f(CW$endUT\fR, access it as \f(CW$$period[6]\fR, \s-1NOT\s0 as
\&\f(CW$$period[\-2]\fR, since I am considering adding more information to the
period description that may speed up performance.
.Sp
\&\f(CW$begUTs\fR is the string representation (\s-1YYYYMMDDHH:MN:SS\s0) of \f(CW$begUT\fR.
Similar for \f(CW$begLTs\fR, \f(CW$endUTs\fR, and \f(CW$endLTs\fR.
.PP
The following methods are available:
.IP "\fBbase\fR" 4
.IX Item "base"
.PD 0
.IP "\fBconfig\fR" 4
.IX Item "config"
.IP "\fBerr\fR" 4
.IX Item "err"
.IP "\fBnew\fR" 4
.IX Item "new"
.IP "\fBnew_config\fR" 4
.IX Item "new_config"
.PD
Please refer to the Date::Manip::Obj documentation for these methods.
.IP "\fBall_periods\fR" 4
.IX Item "all_periods"
.Vb 1
\&   @periods = $tz\->all_periods($zone,$year);
.Ve
.Sp
This returns the description of all time zone periods that occur (in
full or in part) during the given year.  The year is measured in universal
(\s-1GMT\s0) time.
.IP "\fBconvert\fR" 4
.IX Item "convert"
.PD 0
.IP "\fBconvert_to_gmt\fR" 4
.IX Item "convert_to_gmt"
.IP "\fBconvert_from_gmt\fR" 4
.IX Item "convert_from_gmt"
.IP "\fBconvert_to_local\fR" 4
.IX Item "convert_to_local"
.IP "\fBconvert_from_local\fR" 4
.IX Item "convert_from_local"
.PD
These functions convert a date from one time zone to another.
.Sp
.Vb 2
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert($date,$from,$to [,$isdst]);
.Ve
.Sp
This converts a date in the time zone given by \f(CW$from\fR to the time zone
given by \f(CW$to\fR.
.Sp
.Vb 2
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_to_gmt($date [,$from] [,$isdst]);
.Ve
.Sp
This converts a date to \s-1GMT.\s0 If \f(CW$from\fR is given, it is the current
time zone of the date. If \f(CW$from\fR is omitted, it defaults to the local
time zone.
.Sp
The value of \f(CW$isdst\fR returned is always 0.
.Sp
.Vb 2
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_from_gmt($date [,$to]);
.Ve
.Sp
This converts a date from \s-1GMT\s0 to another time zone. If \f(CW$to\fR is given,
the date is converted to that time zone. Otherwise, it is converted
to the local time zone.
.Sp
.Vb 4
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_to_local($date [,$from] [,$isdst]);
\&   ($err,$date,$offset,$isdst,$abbrev) =
\&      $tz\->convert_from_local($date [,$to] [,$isdst]);
.Ve
.Sp
Similar to the \fBconvert_to_gmt\fR and \fBconvert_from_gmt\fR functions. If \f(CW$from\fR
or \f(CW$to\fR are omitted, they default to \s-1GMT.\s0
.Sp
If there is any ambiguity about whether \f(CW$date\fR is in \s-1DST\s0 or not (i.e.
if it is a date that is repeated during a time change due to the clock
being moved back), the \f(CW$isdst\fR option can be passed in as an argument
(it should be 0 or 1) to say which time to use. It is ignored in all
cases where \f(CW$date\fR can be determined without that information.
.Sp
The \f(CW$isdst\fR value passed back is 1 if the converted date is in \s-1DST.\s0 The
\&\f(CW$offset\fR value passed back is a list reference containing the offset from
\&\s-1GMT.\s0 \f(CW$abbrev\fR passed back is the time zone abbreviation.
.Sp
Error codes are:
.Sp
.Vb 5
\&   0  No error
\&   1  Invalid arguments
\&   2  Invalid FROM zone
\&   3  Invalid TO zone
\&   4  Invalid date
.Ve
.IP "\fBcurr_zone\fR" 4
.IX Item "curr_zone"
.Vb 1
\&   $tz\->curr_zone();
.Ve
.Sp
This returns the system time zone. The system time zone is determined
using the methods described below in the
\&\*(L"\s-1DETERMINING THE SYSTEM TIME ZONE\*(R"\s0 section.
.Sp
This is the time zone that is used by default unless the SetDate
or ForceDate config variable is set to a different zone.
.Sp
.Vb 1
\&   $tz\->curr_zone(1);
.Ve
.Sp
This clears the system time zone and re-determines it using the
methods described below.
.Sp
The main reason to do this is if the curr_zone_methods method is
used to change how the time zone is determined.
.IP "\fBcurr_zone_methods\fR" 4
.IX Item "curr_zone_methods"
.Vb 1
\&   $tz\->curr_zone_methods(@methods);
.Ve
.Sp
This sets the list and order of methods to use in determining the
local time zone. The various methods available are listed below in
the section \*(L"\s-1DETERMINING THE SYSTEM TIME ZONE\*(R"\s0.
.Sp
Some methods may require one or more arguments. For example, the
method named \*(L"mainvar\*(R" takes an option that is the name of a
variable. The arguments must be included in the \f(CW@methods\fR list
immediately after the method name (so \f(CW@methods\fR is actually a
mixture of method names and arguments).
.Sp
This method may not be used in any environment where taint
checking is enabled. If it is, it will issue a warning, but
will \s-1NOT\s0 change the method list.
.IP "\fBdate_period\fR" 4
.IX Item "date_period"
.Vb 1
\&   $period = $tz\->date_period($date,$zone,$wall_clock [,$isdst]);
.Ve
.Sp
This returns the period information for the given date. \f(CW$date\fR defaults
to \s-1GMT,\s0 but may be given as local (i.e. wall clock) time if \f(CW$wall_clock\fR
is non-zero. The period information is described in the periods method
below.
.Sp
If a wall clock time is given, no period is returned if the wall clock
time doesn't ever appear (such as when a time change results in the
clock moving forward \*(L"skipping\*(R" a period of time). If the wall clock
time appears twice (i.e. when a time change results in the clock
being set back), the \f(CW$isdst\fR variable is used. The standard time
is used unless \f(CW$isdst\fR is non-zero.  \f(CW$isdst\fR is ignored except in the
case where there are two possible periods.
.IP "\fBdefine_abbrev\fR" 4
.IX Item "define_abbrev"
.Vb 1
\&   ($err,$val) = $tz\->define_abbrev($abbrev,@zone);
.Ve
.Sp
When encountering an abbreviation, by default, all time zones which ever
include the abbreviation will be examine in the order given in the
Date::Manip::Zones manual.
.Sp
Occasionally, it may be necessary to change the order. This is
true if you are parsing dates in a time zone which uses an abbreviation which
is also used in another time zone, and where the other time zone is given
preference. As an example, the abbreviation \*(L"\s-1ADT\*(R"\s0 will default to the
\&\*(L"Atlantic/Bermuda\*(R" time zone. If you are in the \*(L"America/Halifax\*(R" time zone
(which also uses that abbreviation), you may want to change the order
of time zones.
.Sp
This will take an abbreviation (which must be a known
abbreviation... there is no means of defining a totally new
abbreviation) and a list of zones.  This will set the list of zones
that will be checked, and the order in which they are checked, when a
date is encountered with the given abbreviation. It is not necessary
that the list include every zone that has ever used the abbreviation,
but it may not include a zone that has never used it.
.Sp
If \f(CW$abbrev\fR is \*(L"reset\*(R", all abbreviations are reset to the standard
values.  If \f(CW@zone\fR includes only the element 'reset', the default list
for \f(CW$abbrev\fR is restored.
.Sp
The following error codes are returned:
.Sp
.Vb 4
\&   0  No error
\&   1  $abbrev is not a valid abbreviation in any time zone
\&   2  A zone (returned as $val) is not a valid time zone
\&   3  A zone (returned as $val) does not use the abbreviation
.Ve
.Sp
For more information about the different zones which may correspond
to each abbreviation, and the order in which they will be examined
by default, refer to the Date::Manip::Zones manual.
.IP "\fBdefine_alias\fR" 4
.IX Item "define_alias"
.Vb 1
\&   $err = $tz\->define_alias($alias,$zone);
.Ve
.Sp
This will define a new alias (or override an existing alias). \f(CW$zone\fR must
be a valid zone or an error is returned.
.Sp
For more information about the different aliases which are set by
default, refer to the Date::Manip::Zones manual.
.Sp
If \f(CW$alias\fR is \*(L"reset\*(R", all aliases will be reset to the standard values.
If \f(CW$zone\fR is \*(L"reset\*(R", \f(CW$alias\fR will be reset to the standard value.
.IP "\fBdefine_offset\fR" 4
.IX Item "define_offset"
.Vb 1
\&   ($err,$val) = $tz\->define_offset($offset, [$dstflag,] @zone);
.Ve
.Sp
This is similar to the define_abbrev method. When an offset is encountered,
all time zones which have ever included that offset are checked. This will
defined which time zones, and in what order, they should be checked.
.Sp
The zones to both standard and daylight saving times which include the
offset (if \f(CW$dstflag\fR is \*(L"std\*(R" or \*(L"dst\*(R") or to only one or the other.
.Sp
If \f(CW$offset\fR is \*(L"reset\*(R", all lists are reset to the default values.  If
\&\f(CW@zone\fR includes only the element 'reset', the default list and order is
restored for \f(CW$offset\fR ($dstflag must not be given).
.Sp
The following error codes are returned:
.Sp
.Vb 9
\&   0  No error
\&   1  $offset is not a valid offset in any time zone
\&   2  $offset is not a valid offset in the selected
\&      time (if doing "dstonly" or "stdonly")
\&   3  A zone (returned as $val) is not a valid time zone
\&   4  A zone (returned as $val) does not use the offset
\&   5  A zone (returned as $val) does not include the
\&      offset in the selected time (if doing "dstonly"
\&      or "stdonly")
\&
\&   9  Offset is not a valid offset
.Ve
.IP "\fBperiods\fR" 4
.IX Item "periods"
.Vb 1
\&   @periods = $tz\->periods($zone,$year);
.Ve
.Sp
This returns the description of all time zone periods that begin during the
year given. The year is measured in universal (\s-1GMT\s0) time.
.Sp
If no time zone period starts in the given year, nothing is returned.
.Sp
.Vb 1
\&   @periods = $tz\->periods($zone,undef,$year);
.Ve
.Sp
This returns all periods that begin in any year from 0001 to \f(CW$year\fR.
.Sp
.Vb 1
\&   @periods = $tz\->periods($zone,$year0,$year1);
.Ve
.Sp
This returns all periods that begin in any year from \f(CW$year0\fR to \f(CW$year1\fR.
.IP "\fBtzdata\fR" 4
.IX Item "tzdata"
.PD 0
.IP "\fBtzcode\fR" 4
.IX Item "tzcode"
.PD
.Vb 2
\&   $vers = $tz\->tzdata();
\&   $vers = $tz\->tzcode();
.Ve
.Sp
These return the versions of the tzdata and tzcode packages used to
generate the modules.
.IP "\fBzone\fR" 4
.IX Item "zone"
.Vb 2
\&   $zone = $tz\->zone(@args);
\&   @zone = $tz\->zone(@args);
.Ve
.Sp
This function will return a list of all zones, or the default zone,
which matches all of the supplied information. In scalar context,
it will return only the default zone. In list context, it will return
all zones.
.Sp
\&\f(CW@args\fR may include any of the following items, and the order is not
important.
.Sp
.Vb 1
\&   A zone name or alias ($alias)
\&
\&   A zone abbreviation ($abbrev)
\&
\&   An offset ($offset)
\&
\&   A dstflag ($dstflag)
\&
\&   A date ($date)
.Ve
.Sp
It is \s-1NOT\s0 valid to include two of any of the items. Any time zone
returned will match all of the data supplied.
.Sp
If an error occurs, undef is returned. If no zone matches, an empty
string, or an empty list is returned.
.Sp
The order of the zones will be determined in the following way:
.Sp
If \f(CW$abbrev\fR is given, the order of time zones will be determined by it
(and \f(CW$dstflag\fR). If \f(CW$dstflag\fR is \*(L"std\*(R", all zones which match \f(CW$abbrev\fR in
standard time are included, followed by all that match \f(CW$abbrev\fR in
saving time (but no duplication is allowed). The reverse is true if
\&\f(CW$dstflag\fR is \*(L"dst\*(R".
.Sp
If \f(CW$abbrev\fR is not given, but \f(CW$offset\fR is, \f(CW$offset\fR (and \f(CW$dstflag\fR)
will determine the order given. If \f(CW$dstflag\fR is \*(L"std\*(R", all zones
which match \f(CW$offset\fR in standard time are included, followed by
all that match \f(CW$offset\fR in saving time (but no duplication is
allowed). The reverse is true if \f(CW$dstflag\fR is \*(L"dst\*(R".
.Sp
If \f(CW$date\fR is given, only zones in which \f(CW$date\fR will appear in a
zone that matches all other information are given. \f(CW$date\fR is a
wall clock time.
.Sp
If no \f(CW$zone\fR, \f(CW$abbrev\fR, or \f(CW$offset\fR are entered, the local time zone
may be returned (unless \f(CW$date\fR is entered, and it doesn't exist in
the local time zone).
.Sp
\&\s-1NOTE:\s0 there is one important thing to note with respect to \f(CW$dstflag\fR
when you are working with a timezone expressed as an offset and a date
is passed in. In this case, the default value of \f(CW$dstflag\fR is \*(L"dst\*(R"
(\s-1NOT\s0 \*(L"stdonly\*(R"), and you probably never want to pass in a value of
\&\*(L"std\*(R" (though passing in \*(L"stdonly\*(R" is okay).
.Sp
For standard offsets (with no minute component), there is always
a standard timezone which matches that offset. For example,
the timezone \*(L"+0100\*(R" matches the timezone \*(L"Etc/GMT+01\*(R", so you
will never get a timezone in daylight saving time if \f(CW$dstflag\fR
is \*(L"std\*(R".
.Sp
If you want to pass in a date of 2001\-07\-01\-00:00:00 and an timezone
of \*(L"+0100\*(R" and you want to get a timezone that refers to that date
as a daylight saving time date, you must use the \f(CW$dstflag\fR of \*(L"dst\*(R"
(or \*(L"dstonly\*(R").
.Sp
Because this is almost always the behavior desired, when a zone
is passed in as an offset, and a date is passed in, the default
\&\f(CW$dstflag\fR is \*(L"dst\*(R" instead of \*(L"std\*(R". In all other situations,
the default is still \*(L"std\*(R".
.Sp
If the timezone is expressed as an abbreviation, this problem
does not occur.
.SH "TIME ZONE INFORMATION IN DATE::MANIP"
.IX Header "TIME ZONE INFORMATION IN DATE::MANIP"
Date::Manip makes use of three potentially different time zones when
working with a date.
.PP
The first time zone that may be used is the actual local time zone.
This is the time zone that the computer is actually running in.
.PP
The second time zone is the working time zone. Usually, you will want
the default time zone to be the local time zone, but occasionally, you
may want the default time zone to be different.
.PP
The third time zone is the actual time zone that was parsed, or set,
for a date. If a date contains no time zone information, it will
default to the working time zone.
.PP
The local time zone is determined using the methods described in the
following section. Methods exist for locating the zone in one of the
system configuration files, determining it by running a system
command, or by looking it up in the registry (for Windows operating
systems).  If all of these methods fail, the local time zone may be
set using either the \f(CW$::TZ\fR or \f(CW$ENV\fR{\s-1TZ\s0} variables. Please note that
these should \s-1ONLY\s0 be used to set the actual local time zone.
.PP
If you are running in one time zone, but you want to force dates to be
specified in an alternate time zone by default, you need to set the
working time zone. The working time zone defaults to the local time zone,
but this can be changed using either the SetDate or ForceDate
config variables. Refer to the Date::Manip::Config manual for more
information.
.PP
Finally, when a date is actually parsed, if it contains any time zone
information, the date is stored in that time zone.
.SH "DETERMINING THE SYSTEM TIME ZONE"
.IX Header "DETERMINING THE SYSTEM TIME ZONE"
There are a large number of ways available for determining the
time zone. Some or all of them may be checked. A list of methods to use
is provided by default, and may be overridden by the curr_zone_methods
function described above. To override the default order and/or list of
methods, just pass in a list of method names (with arguments where
necessary), and only those methods will be done, and in the order
given.
.PP
The following methods are available:
.PP
.Vb 2
\&   Method     Argument(s)    Procedure
\&   ======     ===========    =========
\&
\&   main       VAR            The main variable named VAR is
\&                             checked. E.g. "main TZ" checks
\&                             the variable $::TZ .
\&
\&   env        TYPE VAR       The named environment variable
\&                             is checked and the type of
\&                             data stored there (TYPE can
\&                             be \*(Aqzone\*(Aq or \*(Aqoffset\*(Aq which
\&                             is the number of seconds from
\&                             UTC).
\&
\&   file       FILE           Look in the given file for any
\&                             one of the following case
\&                             insensitive lines:
\&                                ZONE
\&                                tz = ZONE
\&                                zone = ZONE
\&                                timezone = ZONE
\&                             ZONE may be quoted (single or
\&                             double) and whitespace is
\&                             ignored (except that underscores
\&                             in the zone name may be replaced
\&                             by whitespace on some OSes). If
\&                             the entire line is a zone, it must
\&                             be the first non\-blank non\-comment
\&                             line in the file.
\&
\&   command    COMMAND        Runs a command which produces
\&                             a time zone as the output.
\&
\&   cmdfield   COMMAND N      Runs a command which produces
\&                             whitespace separated fields,
\&                             the Nth one containing the
\&                             time zone (fields are numbered
\&                             starting at 0, or from the
\&                             end starting at \-1).
\&
\&   gmtoff                    Uses the current offset from
\&                             GMT to come up with a best guess.
\&
\&   tzdata     FILE DIR       This uses a system config file that
\&                             contains a pointer to the local tzdata
\&                             files to  determine the timezone.  On
\&                             many operating systems, use:
\&
\&                             tzdata /etc/localtime /usr/share/zoneinfo
\&
\&                             FILE is the system file.  DIR is the
\&                             directory where the tzdata files are stored.
\&
\&                             The config file is either a link to a file
\&                             in the tzdata directory or a copy of one
\&                             of the files.
\&
\&   registry                  Look up the value in the
\&                             Windows registry. This is only
\&                             available to hosts running a
\&                             Windows operating system.
.Ve
.PP
Note that the \*(L"main\*(R" and \*(L"env\*(R" methods should only be used to
specify the actual time zone the system is running in. Use the
SetDate and ForceDate config variables to specify an alternate
time zone that you want to work in.
.PP
By default, the following methods are checked (in the order given) on
Unix systems:
.PP
.Vb 10
\&   main     TZ
\&   env      zone TZ
\&   file     /etc/TIMEZONE
\&   file     /etc/timezone
\&   file     /etc/sysconfig/clock
\&   file     /etc/default/init
\&   command  "/bin/date +%Z"
\&   command  "/usr/bin/date +%Z"
\&   command  "/usr/local/bin/date +%Z"
\&   cmdfield /bin/date             \-2
\&   cmdfield /usr/bin/date         \-2
\&   cmdfield /usr/local/bin/date   \-2
\&   command  "/bin/date +%z"
\&   command  "/usr/bin/date +%z"
\&   command  "/usr/local/bin/date +%z"
\&   tzdata   /etc/localtime /usr/share/zoneinfo
\&   gmtoff
.Ve
.PP
The default methods for Windows systems are:
.PP
.Vb 4
\&   main     TZ
\&   env      zone TZ
\&   registry
\&   gmtoff
.Ve
.PP
The default methods for \s-1VMS\s0 systems are:
.PP
.Vb 8
\&   main     TZ
\&   env      zone TZ
\&   env      zone SYS$TIMEZONE_NAME
\&   env      zone UCX$TZ
\&   env      zone TCPIP$TZ
\&   env      zone MULTINET_TIMEZONE
\&   env      offset SYS$TIMEZONE_DIFFERENTIAL
\&   gmtoff
.Ve
.PP
The default methods for all other systems are:
.PP
.Vb 3
\&   main     TZ
\&   env      zone TZ
\&   gmtoff
.Ve
.PP
If anyone wants better support for a specific \s-1OS,\s0 please contact me and
we'll coordinate adding it.
.PP
In all cases, the value returned from the method may be any of the
following:
.PP
.Vb 2
\&   the full name of a time zone (e.g. America/New_York)
\&   or an alias
\&
\&   an abbreviation (e.g. EDT) which will be used to
\&   determine the zone if possible
\&
\&   an offset (+hh, +hhmn, +hh:mm, +hh:mm:ss) from GMT
.Ve
.PP
The Date::Manip::Zones module contains information about the time zones
and aliases available, and what time zones contain the abbreviations.
.SH "DESIGN ISSUES"
.IX Header "DESIGN ISSUES"
The design decisions made in writing this module may cause some
questions (and probably complaints).  The time zone modules are all
generated using scripts (included in the Date::Manip distribution)
which use the standard tzdata tools to parse the tzdata files and
store that information in perl modules.
.PP
I'd like to address some of them, to avoid answering some of the
\&\*(L"why did you do it that way\*(R" remarks. I do welcome discussion about
these decisions... but preferably after you understand why those
decisions were made so that that we have an informed basis to begin
a discussion.
.IP "\fBWhy not use existing zoneinfo files\fR" 4
.IX Item "Why not use existing zoneinfo files"
Some people will probably think that I should have written an interface to
the zoneinfo files which are distributed with most operating systems.
Although I considered doing that, I rejected the idea for two reasons.
.Sp
First, not all operating systems come with the zoneinfo databases in a
user accessible state (Microsoft for example).  Even those that do
include them store the information in various formats and locations.
In order to bypass all that, I have included the data directly in
these modules.
.Sp
Second, as I was doing my initial investigations into this, I ran into
a bug in the Solaris zoneinfo tools (long since fixed I'm sure).  I
decided then that I didn't want to depend on an implementation where I
could not control and fix the bugs.
.IP "\fBWhy not use the native tzdata files\fR" 4
.IX Item "Why not use the native tzdata files"
Another decision people may question is that I parse the tzdata
files and store the data from them in a large number of perl modules
instead of creating an interface to the tzdata files directly. This
was done solely for the sake of speed.  Date::Manip is already a slow
module.  I didn't want to slow it down further by doing the complex
parsing required to interpret the tzdata files while manipulating
dates.  By storing the data in these modules, there is little or no
parsing done while using Date::Manip modules. It costs a little disk
space to store this information... but very little of it is actually
loaded at runtime (time zone data is only loaded when the time zone
is actually referred to), so I feel it's a good tradeoff.
.IP "\fBWhy store the information in so many files\fR" 4
.IX Item "Why store the information in so many files"
The data from the native tzdata files are parsed and stored in two
sets of modules. These include almost 500 Date::Manip::Offset::*
modules and almost 450 Date::Manip::TZ::* modules.
.Sp
I note that on my linux box, /usr/share/zoneinfo (which contains data
files generated from the tzdata files) contains over 1700 files, so
I'm not doing anything \*(L"new\*(R" by breaking up the information into
separate files. And doing so has a huge impact on performance... it
is not necessary to load and/or manipulate data from time zones which
are not in use.
.Sp
The minute I made the decision to distribute the timezone information
myself, as opposed to using the system version, it was a given that
there would be a lot of files.
.Sp
These modules are loaded only when the time zone or offset is actually
used, so, unless dates from around the world are being parsed, only a
very small number of these modules will actually be loaded. In many
applications, only a single \s-1TZ\s0 module will be loaded. If parsing
dates which have timezone information stored as offsets, one or two
Offset modules will also be loaded.
.IP "\fBThe disk space seems excessive\fR" 4
.IX Item "The disk space seems excessive"
Currently, the disk usage of the perl files is around 9 \s-1MB.\s0 Total disk
usage for /usr/share/zoneinfo on my computer is around 4 \s-1MB.\s0 There are
a couple of differences.
.Sp
The primary difference is that the zoneinfo files are stored in a binary
(and hence, more compressed) version, where the perl modules have all
the data in pure text.
.Sp
Since these are all automatically generated and used, it may be
beneficial to store the data in some packed binary format instead of
the fully expanded text form that is currently in use. This would
decrease the disk space usage, and might improve performance. However,
the performance improvement would happen only once per timezone, and
would make for more complicated code, so I'm not very interested in
pursuing this.
.Sp
Another aspect of the current modules is that they all include pod
documentation. Although not necessary, this allows users to easily
see what modules handle which time zones, and that's nice. It also
allows me to use pod_coverage tests for the module which is a nice
check to make sure that the documentation is accurate.
.Sp
All told, I don't consider the disk usage excessive at all.
.SH "KNOWN PROBLEMS OR ISSUES"
.IX Header "KNOWN PROBLEMS OR ISSUES"
.IP "\fBUnable to determine Time Zone\fR" 4
.IX Item "Unable to determine Time Zone"
When using Date::Manip, when the module is initialized, it must be
able to determine the local time zone. If it fails to do so, an
error will occur:
.Sp
.Vb 1
\&   Unable to determine Time Zone
.Ve
.Sp
and the script will exit.
.Sp
In the past, this was the most common problem with using Date::Manip .
With the release of 6.00, this problem should be significantly less
common. If you do get this error, please refer to the section above
\&\s-1DETERMINING THE SYSTEM TIME ZONE\s0 for information about determining the
local time zone. I am also interested in hearing about this so that I
can update the default list of methods to be able to determine the
local time zone better.
.IP "\fBAsia/Jerusalem time zone\fR" 4
.IX Item "Asia/Jerusalem time zone"
The Asia/Jerusalem time zone has a non-standard way of specifying
the start and end of Daylight Saving Time based on the Hebrew
calendar.
.Sp
As a result, there is no way to specify a simple rule to define
time zone changes for all years in the future. As such, this module
supports all time zone changes currently specified in the zoneinfo
database (which currently goes to the year 2037) but does not attempt
to correctly handle zone changes beyond that date. As a result,
Date::Manip should not be used to parse dates in the Jerusalem
time zone that are far enough in the future that information is not
included in the current version of the zoneinfo database.
.IP "\fB\s-1LMT\s0 and zzz abbreviations\fR" 4
.IX Item "LMT and zzz abbreviations"
Both the \s-1LMT\s0 and zzz abbreviations are used in the zoneinfo databases.
\&\s-1LMT\s0 is use for most time zones for the times before the Gregorian
calendar was adopted, and zzz is used for a few where the time zone was
created and no description of dates prior to that are supported. Both
\&\s-1LMT\s0 and zzz are basically ignored in parsing dates (because there is
no reasonable way to determine which zone they are referring to), and
will be treated as the local time zone regardless.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer to the Date::Manip::Problems documentation for
information on submitting bug reports or questions to the author.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
