.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Log::Dispatch::FileRotate 3"
.TH Log::Dispatch::FileRotate 3 "2021-05-26" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Dispatch::FileRotate \- Log to Files that Archive/Rotate Themselves
.SH "VERSION"
.IX Header "VERSION"
version 1.38
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Log::Dispatch::FileRotate;
\&
\&  my $logger = Log::Dispatch::FileRotate\->new(
\&      name      => \*(Aqfile1\*(Aq,
\&      min_level => \*(Aqinfo\*(Aq,
\&      filename  => \*(AqSomefile.log\*(Aq,
\&      mode      => \*(Aqappend\*(Aq ,
\&      size      => 10*1024*1024,
\&      max       => 6);
\&
\&  # or for a time based rotation
\&
\&  my $logger = Log::Dispatch::FileRotate\->new(
\&      name      => \*(Aqfile1\*(Aq,
\&      min_level => \*(Aqinfo\*(Aq,
\&      filename  => \*(AqSomefile.log\*(Aq,
\&      mode      => \*(Aqappend\*(Aq ,
\&      TZ        => \*(AqAEDT\*(Aq,
\&      DatePattern => \*(Aqyyyy\-dd\-HH\*(Aq);
\&
\&  # and attach to Log::Dispatch
\&  my $dispatcher = Log::Dispatch\->new;
\&  $dispatcher\->add($logger);
\&
\&  $dispatcher\->log( level => \*(Aqinfo\*(Aq, message => "your comment\en" );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module extends the base class Log::Dispatch::Output to provides a
simple object for logging to files under the Log::Dispatch::* system, and
automatically rotating them according to different constraints. This is
basically a Log::Dispatch::File wrapper with additions.
.SS "Rotation"
.IX Subsection "Rotation"
There are three different constraints which decide when a file must be
rotated.
.PP
The first is by size: when the log file grows more than a specified
size, then it's rotated.
.PP
The second constraint is with occurrences. If a \*(L"DatePattern\*(R" is defined, a
file rotation ignores size constraint (unless \f(CW\*(C`check_both\*(C'\fR) and uses the
defined date pattern constraints. When using \*(L"DatePattern\*(R" make sure \s-1TZ\s0 is
defined correctly and that the \s-1TZ\s0 you use is understood by Date::Manip. We use
Date::Manip to generate our recurrences. Bad \s-1TZ\s0 equals bad recurrences equals
surprises! Read the Date::Manip man page for more details on
\&\s-1TZ.\s0 \*(L"DatePattern\*(R" will default to a daily rotate if your entered pattern is
incorrect. You will also get a warning message.
.PP
You can also check both constraints together by using the \f(CW\*(C`check_both\*(C'\fR
parameter.
.PP
The latter constraint is a user callback. This function is called outside the
restricted area (see \*(L"Concurrency\*(R") and,
if it returns a true value, a rotation will happen unconditionally.
.PP
All check are made before logging. The \f(CW\*(C`rotate\*(C'\fR method leaves us check these
constraints without logging anything.
.PP
To let more power at the user, a \f(CW\*(C`post_rotate\*(C'\fR callback it'll call after every
rotation.
.SS "Concurrency"
.IX Subsection "Concurrency"
Multiple writers are allowed by this module. There is a restricted area where
only one writer can be inside. This is done by using an external lock file,
which name is "\f(CW\*(C`.filename.LCK\*(C'\fR" (never deleted).
.PP
The user constraint and the \*(L"DatePattern\*(R" constraint are checked outside this
restricted area. So, when you write a callback, don't rely on the logging
file because it can disappear under your feet.
.PP
Within this restricted area we:
.IP "\(bu" 4
check the size constraint
.IP "\(bu" 4
eventually rotate the log file
.IP "\(bu" 4
if it's defined, call the \f(CW\*(C`post_rotate\*(C'\fR function
.IP "\(bu" 4
write the log message
.SH "METHODS"
.IX Header "METHODS"
.SS "new(%p)"
.IX Subsection "new(%p)"
The constructor takes the following parameters in addition to parameters
documented in Log::Dispatch::File:
.IP "max ($)" 4
.IX Item "max ($)"
The maximum number of log files to create. Default 1.
.IP "size ($)" 4
.IX Item "size ($)"
The maximum (or close to) size the log file can grow too. Default 10M.
.IP "DatePattern ($)" 4
.IX Item "DatePattern ($)"
The \*(L"DatePattern\*(R" as defined above.
.IP "\s-1TZ\s0 ($)" 4
.IX Item "TZ ($)"
The TimeZone time based calculations should be done in. This should match
Date::Manip's concept of timezones and of course your machines timezone.
.IP "check_both ($)" 4
.IX Item "check_both ($)"
1 for checking \*(L"DatePattern\*(R" and size concurrently, 0 otherwise.  Default 0.
.IP "user_constraint (\e&)" 4
.IX Item "user_constraint (&)"
If this callback is defined and returns true, a rotation will happen
unconditionally.
.IP "post_rotate (\e&)" 4
.IX Item "post_rotate (&)"
This callback is called after that all files were rotated. Will be called one
time for every rotated file (in reverse order) with this arguments:
.RS 4
.ie n .IP """filename""" 4
.el .IP "\f(CWfilename\fR" 4
.IX Item "filename"
the path of the rotated file
.ie n .IP """index""" 4
.el .IP "\f(CWindex\fR" 4
.IX Item "index"
the index of the rotated file from \f(CW\*(C`max\*(C'\fR\-1 to 0, in the latter case
\&\f(CW\*(C`filename\*(C'\fR is the new, empty, log file
.ie n .IP """fileRotate""" 4
.el .IP "\f(CWfileRotate\fR" 4
.IX Item "fileRotate"
a object reference to this instance
.RE
.RS 4
.Sp
With this, you can have infinite files renaming each time the rotated file
log. E.g:
.Sp
.Vb 10
\&  my $file = Log::Dispatch::FileRotate
\&  \->new(
\&        ...
\&        post_rotate => sub {
\&          my ($filename, $idx, $fileRotate) = @_;
\&          if ($idx == 1) {
\&            use POSIX qw(strftime);
\&            my $basename = $fileRotate\->filename();
\&            my $newfilename =
\&              $basename . \*(Aq.\*(Aq . strftime(\*(Aq%Y%m%d%H%M%S\*(Aq, localtime());
\&            $fileRotate\->debug("moving $filename to $newfilename");
\&            rename($filename, $newfilename);
\&          }
\&        },
\&       );
.Ve
.Sp
\&\fBNote\fR: this is called within the restricted area (see \*(L"Concurrency\*(R"). This
means that any other concurrent process is locked in the meanwhile. For the
same reason, don't use the \f(CW\*(C`log()\*(C'\fR or \f(CW\*(C`log_message()\*(C'\fR methods because you
will get a deadlock!
.RE
.IP "\s-1DEBUG\s0 ($)" 4
.IX Item "DEBUG ($)"
Turn on lots of warning messages to \s-1STDERR\s0 about what this module is
doing if set to 1. Really only useful to me.
.SS "\fBfilename()\fP"
.IX Subsection "filename()"
Returns the log filename.
.SS "setDatePattern( $ or [ $, $, ... ] )"
.IX Subsection "setDatePattern( $ or [ $, $, ... ] )"
Set a new suite of recurrances for file rotation. You can pass in a
single string or a reference to an array of strings. Multiple recurrences
can also be define within a single string by seperating them with a
semi-colon (;)
.PP
See the discussion above regarding the setDatePattern paramater for more
details.
.SS "log_message( message => $ )"
.IX Subsection "log_message( message => $ )"
Sends a message to the appropriate output.  Generally this shouldn't
be called directly but should be called through the \f(CW\*(C`log()\*(C'\fR method
(in Log::Dispatch::Output).
.SS "\fBrotate()\fP"
.IX Subsection "rotate()"
Rotates the file, if it has to be done. You can call this method if you want to
check, and eventually do, a rotation without logging anything.
.PP
Returns 1 if a rotation was done, 0 otherwise. \f(CW\*(C`undef\*(C'\fR on error.
.SS "debug($)"
.IX Subsection "debug($)"
If \f(CW\*(C`DEBUG\*(C'\fR is true, prints a standard warning message.
.SH "Tip"
.IX Header "Tip"
If you have multiple writers that were started at different times you
will find each writer will try to rotate the log file at a recurrence
calculated from its start time. To sync all the writers just use a config
file and update it after starting your last writer. This will cause
\&\f(CW\*(C`new()\*(C'\fR to be called by each of the writers
close to the same time, and if your recurrences aren't too close together
all should sync up just nicely.
.PP
I initially assumed a long running process but it seems people are using
this module as part of short running \s-1CGI\s0 programs. So, now we look at the
last modified time stamp of the log file and compare it to a previous
occurance of a \*(L"DatePattern\*(R", on startup only. If the file stat shows
the mtime to be earlier than the previous recurrance then I rotate the
log file.
.SH "DatePattern"
.IX Header "DatePattern"
As I said earlier we use Date::Manip for generating our recurrence
events. This means we can understand Date::Manip's recurrence patterns
and the normal log4j DatePatterns. We don't use DatePattern to define the
extension of the log file though.
.PP
DatePattern can therefore take forms like:
.PP
.Vb 4
\&      Date::Manip style
\&            0:0:0:0:5:30:0       every 5 hours and 30 minutes
\&            0:0:0:2*12:30:0      every 2 days at 12:30 (each day)
\&            3*1:0:2:12:0:0       every 3 years on Jan 2 at noon
\&
\&      DailyRollingFileAppender log4j style
\&            yyyy\-MM              every month
\&            yyyy\-ww              every week
\&            yyyy\-MM\-dd           every day
\&            yyyy\-MM\-dd\-a         every day at noon
\&            yyyy\-MM\-dd\-HH        every hour
\&            yyyy\-MM\-dd\-HH\-MM     every minute
.Ve
.PP
To specify multiple recurrences in a single string separate them with a
semicolon:
        yyyy-MM-dd; 0:0:0:2*12:30:0
.PP
This says we want to rotate every day \s-1AND\s0 every 2 days at 12:30. Put in
as many as you like.
.PP
A complete description of Date::Manip recurrences is beyond us here
except to quote (from the man page):
.PP
.Vb 4
\&           A recur description is a string of the format
\&           Y:M:W:D:H:MN:S .  Exactly one of the colons may
\&           optionally be replaced by an asterisk, or an asterisk
\&           may be prepended to the string.
\&
\&           Any value "N" to the left of the asterisk refers to
\&           the "Nth" one.  Any value to the right of the asterisk
\&           refers to a value as it appears on a calendar/clock.
\&           Values to the right can be listed a single values,
\&           ranges (2 numbers separated by a dash "\-"), or a comma
\&           separated list of values or ranges.  In a few cases,
\&           negative values are appropriate.
\&
\&           This is best illustrated by example.
\&
\&             0:0:2:1:0:0:0        every 2 weeks and 1 day
\&             0:0:0:0:5:30:0       every 5 hours and 30 minutes
\&             0:0:0:2*12:30:0      every 2 days at 12:30 (each day)
\&             3*1:0:2:12:0:0       every 3 years on Jan 2 at noon
\&             0:1*0:2:12,14:0:0    2nd of every month at 12:00 and 14:00
\&             1:0:0*45:0:0:0       45th day of every year
\&             0:1*4:2:0:0:0        4th tuesday (day 2) of every month
\&             0:1*\-1:2:0:0:0       last tuesday of every month
\&             0:1:0*\-2:0:0:0       2nd to last day of every month
.Ve
.SH "TODO"
.IX Header "TODO"
compression, signal based rotates, proper test suite
.PP
Could possibly use Logfile::Rotate as well/instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Log::Dispatch::File::Stamped
.Sp
Log directly to timestamped files.
.SH "HISTORY"
.IX Header "HISTORY"
Originally written by Mark Pfeiffer, <markpf at mlp-consulting dot com dot au>
inspired by Dave Rolsky's, <autarch at urth dot org>, code :\-)
.PP
Kevin Goess <cpan at goess dot org> suggested multiple writers should be
supported. He also conned me into doing the time based stuff.  Thanks Kevin!
:\-)
.PP
Thanks also to Dan Waldheim for helping with some of the locking issues in a
forked environment.
.PP
And thanks to Stephen Gordon for his more portable code on lockfile naming.
.SH "SOURCE"
.IX Header "SOURCE"
The development version is on github at <https://https://github.com/mschout/perl\-log\-dispatch\-filerotate>
and may be cloned from <git://https://github.com/mschout/perl\-log\-dispatch\-filerotate.git>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
<https://github.com/mschout/perl\-log\-dispatch\-filerotate/issues>
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Schout <mschout@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2005 by Mark Pfeiffer.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
