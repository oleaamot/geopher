.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Date::Manip::Delta 3"
.TH Date::Manip::Delta 3 "2022-06-01" "perl v5.36.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Delta \- Methods for working with deltas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Date::Manip::Delta;
\&   $date = new Date::Manip::Delta;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains functions useful in parsing and manipulating
deltas.  As used in this module, the term delta refers to an amount
of time elapsed.  It includes no information about a starting or
ending time.
.PP
There are several concepts involved in understanding the properties
of a delta.
.IP "\fBstandard and business delta\fR" 4
.IX Item "standard and business delta"
There are two different modes for working with deltas: standard and
business.  The mode used depends on how you treat the calendar.
.Sp
Standard deltas use the full calendar without any modifications.
.Sp
A business delta uses a calendar in the way a business might.  In a
business calendar, anything outside of a business day is ignored.
Typically, this includes holidays and weekends.  In addition, the part
of the day outside of business hours is also ignored, so a day may
only run from 08:00 to 17:00 and everything outside of this is
ignored.
.Sp
The length of a work day is usually not 24 hours.  It is defined by
the start and end of the work day and is set using the config
variables: \fBWorkDayBeg\fR and \fBWorkDayEnd\fR (\fBWorkDay24Hr\fR may be used to
specify a 24\-hour work day).  The work week is defined using the
config variables: \fBWorkWeekBeg\fR and \fBWorkWeekEnd\fR.
.Sp
Daylight saving time are ignored with business calculations because
time changes occur at night (usually on the weekends) outside of
business hours.  This may yield unexpected results if the work day is
defined to be 24\-hours and the work week includes a day when a time
change occurs.
.IP "\fBfields\fR" 4
.IX Item "fields"
A delta consists of 7 fields: years, months, weeks, days, hours,
minutes, and seconds, usually expressed as a colon-separated string.
For example:
.Sp
.Vb 1
\&   1:2:3:4:5:6:7
.Ve
.Sp
refers to an elapsed amount of time 1 year, 2 months, 3 weeks, 4 days,
5 hours, 6 minutes, and 7 seconds long.
.IP "\fBnormalized\fR" 4
.IX Item "normalized"
A delta can be normalized or not. A normalized delta has values which
have been simplified based on how a human would think of them.  As an
example, the delta:
.Sp
.Vb 1
\&   0:0:0:0:0:10:70
.Ve
.Sp
is not normalized since 70 seconds is typically thought of as 1 minute
10 seconds. The normalized form of this delta would be:
.Sp
.Vb 1
\&   0:0:0:0:0:11:10
.Ve
.Sp
By default, deltas are converted to a normalized form in most
functions that create/modify a delta, but this can be overridden.
.IP "\fBTypes of deltas\fR" 4
.IX Item "Types of deltas"
There are 4 type of deltas that are available.
.RS 4
.IP "Exact deltas" 8
.IX Item "Exact deltas"
The most common type (and the default in most situations) is an exact
delta.  An exact delta is one where only fields which have exactly
known lengths are allowed to be non-zero.
.Sp
For standard calculations, there are only three exactly known fields
(hours, minutes, and seconds).  The lengths are defined as:
.Sp
.Vb 2
\&   1 hour   = 3600 seconds
\&   1 minute = 60 seconds
.Ve
.Sp
Note that since a day is \s-1NOT\s0 always 24 hours (due to daylight saving time
changes), a day is not an exactly known field.
.Sp
For business calculations, a day \s-1IS\s0 an exactly known field.  Since
business mode ignores daylight saving time, the length of the day can
be calculated based on the config variables listed above.  So, for
example, if the work day is 08:00\-17:00, the length of the day is 9
hours.  The length of the week is still unknown since some work weeks
may have fewer days than others due to holidays.
.Sp
All fields which are not exactly known will always have zero value.
.IP "Semi-exact deltas" 8
.IX Item "Semi-exact deltas"
A semi-exact delta treats the day/week fields as if they were exactly
known.
.Sp
For standard calculations, this is done by using the relationships:
.Sp
.Vb 2
\&   1 day  = 24 hours
\&   1 week = 7 days
.Ve
.Sp
For business calculations, it is done by treating a week as a constant
length (determined by the config variables listed above) ignoring
holidays.  So if a typical work week is Mon-Fri, the length of the
week is 5 days.
.Sp
For semi-exact deltas, the value of the year/month must be zero.
.Sp
Although this may yield some values that are not exactly accurate
around daylight saving time transitions, strictly speaking, they yield
results that are useful in terms of how humans think of deltas.
.IP "Approximate deltas" 8
.IX Item "Approximate deltas"
An approximate delta can have non-zero values for all fields.  When normalizing
the fields, the year/month fields are treated as one set using the relationship
.Sp
.Vb 1
\&   1 year  = 12 months
.Ve
.Sp
The remaining fields are normalized using the semi-exact relationships.
.IP "Estimated deltas" 8
.IX Item "Estimated deltas"
The final type of delta are estimated deltas.  These are deltas where
an estimated length is applied to all the approximate fields.
.Sp
For standard deltas, the additional relationship:
.Sp
.Vb 1
\&   1 year = 365.2425 days
.Ve
.Sp
is used.  For business deltas, the additional relationship:
.Sp
.Vb 1
\&   1 year   = X/7 * 365.2425 days
.Ve
.Sp
(where X is the number of work days in a week) is used.
.Sp
Fractional seconds will be discarded (not rounded).
.RE
.RS 4
.Sp
\&\s-1NOTE:\s0 it is not possible to look at a delta and determine what type
it is.  For example, a standard delta with a non-zero day value might
be approximate or semi-exact.  The type will need to be explicitly
selected, or determined by the context of the operation.
.RE
.IP "\fBsigns\fR" 4
.IX Item "signs"
Each field has a sign associated with it. For example, the
delta \*(L"1 year ago\*(R" is written as:
.Sp
.Vb 1
\&   \-1:0:0:0:0:0:0
.Ve
.Sp
The sign of any field is optional, and if omitted, it is the
same as the next higher field.  So, the following are identical:
.Sp
.Vb 2
\&   +1:2:3:4:5:6:7
\&   +1:+2:+3:+4:+5:+6:+7
.Ve
.Sp
In a normalized delta, all fields in a set will have the same
sign.  So the standard delta:
.Sp
.Vb 1
\&   0:0:+3:\-2:0:0:0:0   (3 weeks \-2 days)
.Ve
.Sp
is not normalized.  The normalized version would be:
.Sp
.Vb 1
\&   0:0:+2:5:0:0:0:0    (2 weeks, 5 days)
.Ve
.Sp
Since an approximate delta has two sets (the y/m set and the w/d/h/mn/s set),
these deltas may have two signs. So, the following is a
fully normalized approximate delta:
.Sp
.Vb 1
\&   +1:0:\-3:3:1:0:0
.Ve
.IP "\fBfractional values\fR" 4
.IX Item "fractional values"
Fractional fields are allowed such as:
.Sp
.Vb 2
\&   1.25 days
\&   1.1 years
.Ve
.Sp
but whenever parsing a delta with fractional fields, the delta will be
normalized using the estimated relationships described above.  Fractional
seconds will be discarded.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.PD 0
.IP "\fBnew_config\fR" 4
.IX Item "new_config"
.IP "\fBnew_date\fR" 4
.IX Item "new_date"
.IP "\fBnew_delta\fR" 4
.IX Item "new_delta"
.IP "\fBnew_recur\fR" 4
.IX Item "new_recur"
.IP "\fBbase\fR" 4
.IX Item "base"
.IP "\fBtz\fR" 4
.IX Item "tz"
.IP "\fBis_date\fR" 4
.IX Item "is_date"
.IP "\fBis_delta\fR" 4
.IX Item "is_delta"
.IP "\fBis_recur\fR" 4
.IX Item "is_recur"
.IP "\fBconfig\fR" 4
.IX Item "config"
.IP "\fBerr\fR" 4
.IX Item "err"
.PD
Please refer to the Date::Manip::Obj documentation for these methods.
.IP "\fBparse\fR" 4
.IX Item "parse"
.Vb 2
\&   $err = $delta\->parse($string, \e%opts);
\&   $err = $delta\->parse($string [,$business] [,$no_normalize]);
.Ve
.Sp
The second format is supported for backward compatibility, but is
deprecated and will be removed in Date::Manip 7.00.  The second form
is equivalent to:
.Sp
.Vb 2
\&   $err = $delta\->parse($string, { business => $business,
\&                                   nonorm   => $no_normalize });
.Ve
.Sp
This takes a string and parses it to see if it is a valid delta. If it is,
an error code of 0 is returned and \f(CW$delta\fR now contains the value of the
delta. Otherwise, an error code of 1 is returned and an error condition
is set in the delta.
.Sp
Recognized options are:
.Sp
.Vb 5
\&   mode      : standard/business
\&               to specify if it is a business delta or a standard delta
\&   nonorm    : 0/1
\&               1 if the delta should not be normalized
\&   type      : exact, semi, approx, estimated
.Ve
.Sp
When specifying the type, the delta given must satisfy the requirements
of the type (i.e. no year field for an exact delta).
.Sp
A delta string is usually specified in compact notation which consists
of a colon separated list of numbers (with optional signs):
.Sp
.Vb 4
\&   Examples:
\&      0:0:0:0:4:3:\-2
\&      +4:3:\-2
\&      +4::3
.Ve
.Sp
In compact notation, from 1 to 7 of the fields may be given.  For
example D:H:MN:S may be given to specify only four of the fields.  No
spaces may be present in the string, but it is allowed to omit
some of the fields. For example 5::3:30 is valid. In this case,
missing fields default to the value 0.
.Sp
The delta string may also be specified using common field
abbreviations.  This is described below in the
\&\*(L"\s-1ADDITIONAL DELTA NOTATIONS\*(R"\s0 section.
.IP "\fBinput\fR" 4
.IX Item "input"
.Vb 1
\&   $str = $delta\->input();
.Ve
.Sp
This returns the string that was parsed to form the delta.
.IP "\fBset\fR" 4
.IX Item "set"
.Vb 2
\&   $err = $delta\->set(\e%opts);
\&   $err = $delta\->set($field,$val [,$no_normalize]);
.Ve
.Sp
The second format is supported for backward compatibility, but is
deprecated and will be removed in Date::Manip 7.00.  The second form
is equivalent to:
.Sp
.Vb 1
\&   $err = $delta\->set( $field => $val, \*(Aqnonorm\*(Aq => $no_normalize );
.Ve
.Sp
This explicitly sets one or more parts of a delta.  \f(CW%opts\fR is a set of
key/value pairs:
.Sp
.Vb 1
\&   $key     $val
\&
\&   delta    [Y,M,W,D,H,MN,S]  sets the entire delta
\&   business [Y,M,W,D,H,MN,S]  sets the entire delta
\&   standard [Y,M,W,D,H,MN,S]  sets the entire delta
\&   y        YEAR              sets one field
\&   M        MONTH
\&   w        WEEK
\&   d        DAY
\&   h        HOUR
\&   m        MINUTE
\&   s        SECOND
\&
\&   nonorm   0/1
\&   mode     business, standard
\&   type     exact, semi, estimated, approx
.Ve
.Sp
An error is returned if an invalid data is passed in.
.Sp
\&\f(CW%opts\fR can only include a single key that affects each field (i.e. you
can set \fBdelta\fR or \fBbusiness\fR but not both, and you cannot set both
\&\fBdelta\fR and \fBy\fR, but you \s-1CAN\s0 set both \fBy\fR and \fBw\fR).
.Sp
When setting the entire delta with \fBbusiness\fR or \fBstandard\fR, it flags
the delta as a business or standard mode delta respectively. In those
cases, you are not allowed to set the \fBmode\fR option.  Partial deltas
are allowed (i.e. [H,MN,S]) in which case zeros are added for all fields
not specified.
.Sp
When setting the entire delta with \fBdelta\fR, the flag is left
unchanged (unless the \fBmode\fR option is also passed in).
.Sp
Also, when setting the entire delta, signs are not carried from
one field to another, so [\-1,2,...] is equivalent to [\-1,+2,...].
.Sp
By default, a delta is normalized, but setting the \fBnonorm\fR key to
a true value will not do that.
.Sp
For backwards compatibility, \fBnormal\fR can be used in place of \fBstandard\fR,
both as \f(CW$field\fR or as \f(CW$val\fR.  This is deprecated and will be removed in
Date::Manip 7.00.
.Sp
When setting any field in the delta, the type of delta will be determined
automatically as either \fBexact\fR (if only fields that are exactly known
are have non-zero fields), \fBsemi\fR (if only fields that are semi-exact or
exact are included), or \fBapprox\fR otherwise.  If the \fBtype\fR option is
set, it will be used provided it is valid (i.e. you cannot set it to \fBexact\fR
if fields that are not exactly known are set).
.IP "\fBprintf\fR" 4
.IX Item "printf"
.Vb 2
\&   $out = $delta\->printf($in);
\&   @out = $delta\->printf(@in);
.Ve
.Sp
This takes a string or list of strings which may contain any number of
special formatting directives. These directives are replaced with
information contained in the delta. Everything else in the string is
returned unmodified.
.Sp
A directive always begins with '%'. They are described in the section
below in the section \*(L"\s-1PRINTF DIRECTIVES\*(R"\s0.
.IP "\fBcalc\fR" 4
.IX Item "calc"
Please refer to the Date::Manip::Calc documentation for details.
.IP "\fBtype\fR" 4
.IX Item "type"
.Vb 1
\&   $flag = $delta\->type($op);
.Ve
.Sp
This tests to see if a delta is of a certain type. \f(CW$op\fR can be;
.Sp
.Vb 2
\&   business  : returns 1 if it is a business delta
\&   standard  : returns 1 if it is a standard (non\-business delta)
\&
\&   exact     : returns 1 if it is exact
\&   semi      : returns 1 if it is semi\-exact
\&   approx    : returns 1 if it is approximate
\&   estimated : returns 1 if it is estimated
.Ve
.IP "\fBvalue\fR" 4
.IX Item "value"
.Vb 2
\&   $val = $delta\->value();
\&   @val = $delta\->value();
.Ve
.Sp
This returns the value of the delta. In scalar context, it returns
the printable string (equivalent to the printf directive '%Dt'). In
list context, it returns a list of fields.
.Sp
An empty string/list is returned if there is no valid delta stored in \f(CW$delta\fR.
.IP "\fBconvert\fR" 4
.IX Item "convert"
.Vb 1
\&   $delta\->convert($to);
.Ve
.Sp
This converts a delta from one type to another.  \f(CW$to\fR can be 'exact',
\&'semi', or 'approx'.  The conversion uses the approximate and estimated
relationships listed above to convert the delta.
.Sp
For example, if the exact non-business delta \f(CW$delta\fR contains:
.Sp
.Vb 1
\&   0:0:0:0:44:0:0
.Ve
.Sp
then the following call:
.Sp
.Vb 1
\&   $delta\->convert(\*(Aqsemi\*(Aq)
.Ve
.Sp
would produce the semi-exact delta:
.Sp
.Vb 1
\&   0:0:0:1:20:0:0
.Ve
.Sp
The result will always be normalized.
.Sp
Converting from one type to another that is less exact (i.e. exact to semi-exact
or semi-exact to approx) is supported.  Converting the other direction is
supported for backward compatibility, but will be removed in 7.00 because
that operation is not one that is well defined.
.Sp
There is currently no support for converting business to non-business
(or vice-versa).
.IP "\fBcmp\fR" 4
.IX Item "cmp"
.Vb 1
\&   $flag = $delta1\->cmp($delta2);
.Ve
.Sp
This compares two deltas (using the approximate relationships listed
above) and returns \-1, 0, or 1 which could be used to sort them by length
of time.
.Sp
Both deltas must be valid, and both must be either business or
non-business deltas.  They do not need to be the same out of exact,
semi-exact, and approximate.
.Sp
undef will be returned if either delta is invalid, or you try to compare
a business and non-business delta.
.SH "ADDITIONAL DELTA NOTATIONS"
.IX Header "ADDITIONAL DELTA NOTATIONS"
When parsing a delta, the string may be specified with the field spelled
out, rather than using the colon separated fields.
.PP
This expanded notation has the fields spelled out in some language
specific form:
.PP
.Vb 5
\&   Examples:
\&      +4 hours +3mn \-2second
\&      + 4 hr 3 minutes \-2
\&      4 hour + 3 min \-2 s
\&      4 hr 2 s
.Ve
.PP
A field in the expanded notation has an optional sign, a number, and a
string specifying the type of field.  If the sign is absent, it
defaults to the sign of the next larger element.  So the following are
equivalent:
.PP
.Vb 2
\&   \-4 hr 3 min 2 sec
\&   \-4 hr \-3 min \-2 sec
.Ve
.PP
The valid strings describing each of the fields is contained in \*(L"Delta field
names\*(R" section of the appropriate Date::Manip::Lang::<\s-1LANGUAGE\s0> document.
Refer to the Date::Manip::Lang document for a list of languages.
.PP
For example, for English, the document is Date::Manip::Lang::English and
the field names include strings like:
.PP
.Vb 7
\&   y:  y, yr, year, years
\&   m:  m, mon, mons, month, months
\&   w:  w, wk, ws, wks, week, weeks
\&   d:  d, day, days
\&   h:  h, hr, hrs, hour, hours
\&   mn: mn, min, mins, minute, minutes
\&   s:  s, sec, secs, second, seconds
.Ve
.PP
This list may not be complete.  You should refer to the language document
for the full list.
.PP
The \*(L"seconds\*(R" string may be omitted.  The sign, number, and string may
all be separated from each other by any amount of whitespace. The
string specifying the unit must be separated from a following number
by whitespace or a comma, so the following example will \s-1NOT\s0 work:
.PP
.Vb 1
\&   4hours3minutes
.Ve
.PP
At minimum, it must be expressed as:
.PP
.Vb 2
\&   4hours 3minutes
\&   4 hours, 3 minutes
.Ve
.PP
In the the expanded format, all fields must be given in the order: Y M
W D H \s-1MN S.\s0  Any number of them may be omitted provided the rest
remain in the correct order. Small numbers may be spelled out, so
.PP
.Vb 2
\&   in two weeks
\&   in 2 weeks
.Ve
.PP
both work (but do not rely on this to work for large numbers).
.PP
Most languages also allow a word to specify whether the delta is an
amount of time after or before a fixed point. In English, the word \*(L"in\*(R"
refers to a time after a fixed point, and \*(L"ago\*(R" refers to a point before
a fixed point. So, the following deltas are equivalent:
.PP
.Vb 2
\&  1:0:0:0:0:0:0
\&  in 1 year
.Ve
.PP
and the following are equivalent
.PP
.Vb 2
\&  \-1:0:0:0:0:0:0
\&  1 year ago
.Ve
.PP
The word \*(L"in\*(R" is completely ignored. The word \*(L"ago\*(R" has the affect of
reversing all signs that appear in front of the components of the
delta.  In other words, the following two strings are identical:
.PP
.Vb 2
\&   \-12 yr  6 mon ago
\&   +12 yr +6 mon
.Ve
.PP
(don't forget that there is an implied minus sign in front of the 6 in
the first string because when no sign is explicitly given, it carries
the previously entered sign).
.PP
The in/ago words only apply to the expanded format, so the following
is invalid:
.PP
.Vb 1
\&   1:0:0 ago
.Ve
.PP
A delta may be standard (non-business) or business. By default, a delta
is treated as a non-business delta, but this can be changed in two
different ways.
.PP
The first way to make a delta be business is to pass in the appropriate
option.  For example:
.PP
.Vb 2
\&  $delta\->parse($string, { \*(Aqmode\*(Aq => \*(Aqbusiness\*(Aq });
\&  $delta\->parse($string, { \*(Aqmode\*(Aq => \*(Aqstandard\*(Aq });
.Ve
.PP
The second way to specify whether a delta is business or non-business
is to include a key word in the string that is parsed. If this string
is included, it should not conflict with the value of a 'mode' option.
.PP
Most languages include a word like \*(L"business\*(R" which can be used to
specify that the resulting delta is a business delta or a non-business
delta. Other languages have equivalent words. The placement of the
word is not important. Also, the \*(L"business\*(R" word can be included with
all types of deltas, and in both compact and expanded notation, so the
following are valid and equivalent:
.PP
.Vb 3
\&   in 4 hours business
\&   4:0:0 business
\&   business 0:0:0:0:4:0:0
.Ve
.PP
There are also words \*(L"exact\*(R" or \*(L"approximate\*(R" which may be included in
the delta for backward compatibility.  However, they will be ignored.
They will be removed in Date::Manip 7.00.  The accuracy of delta
(exact, semi-exact, approximate) will be determined only by what
fields are present in the delta and the options passed in.
When a delta is parsed, it is automatically normalized, unless the
\&'nonorm' option is passed in.
.SH "PRINTF DIRECTIVES"
.IX Header "PRINTF DIRECTIVES"
The following printf directives are replaced with information
from the delta. Directives may be replaced by the values of a
single field in the delta (i.e. the hours or weeks field),
the value of several fields expressed in terms of one of them
(i.e. the number of years and months expressed in terms of
months), or the directive may format either the entire delta,
or portions of it.
.IP "\fBSimple directives\fR" 4
.IX Item "Simple directives"
These are directives which print simple characters. Currently, the
only one is:
.Sp
.Vb 1
\&   %%    Replaced by a single \*(Aq%\*(Aq
.Ve
.Sp
As an example:
.Sp
.Vb 2
\&  $delta\->printf(\*(Aq|%%|\*(Aq);
\&     => |%|
.Ve
.IP "\fBDirectives to print out a single field\fR" 4
.IX Item "Directives to print out a single field"
The following directive is used to print out the value of a single
field. Spaces are included here for clarity, but are not in the
actual directive.
.Sp
.Vb 1
\&   % [+] [pad] [width] Xv
.Ve
.Sp
Here, X is one of (y,M,w,d,h,m,s). The directive will print out the
value for that field.
.Sp
If a '+' is included immediately after the '%', a sign will always be
included. By default, only negative values will include a sign.
.Sp
\&'width' and 'pad' are used to set the width of the string containing
the field as well as how it is padded.
.Sp
\&'width' is any positive integer (without a sign). If 'width' is
included, it sets the length of the output string (unless the string
is already longer than that, in which case the 'width' is ignored).
.Sp
If 'pad' is included, it may be the character '<', '>', or '0'. It
will be ignored if 'width' is not included, or the string is already
longer than 'width'.  If the formatted delta field is shorter than
\&'width', it will be padded with spaces on the left (if 'pad' is '<'),
or right (if 'pad' is '>'), or it will be padded on the left (after
any sign) with zeroes (if 'pad' is '0').
.Sp
In the following examples, \f(CW$delta\fR contains the delta: 1:2:3:4:5:6:7
.Sp
.Vb 2
\&   $delta\->printf(\*(Aq|Month: %Mv|\*(Aq);
\&      => |Month: 2|
\&
\&   $delta\->printf(\*(Aq|Day: %+05dv|\*(Aq);
\&      => |Day: +0004|
\&
\&   $delta\->printf(\*(Aq|Day: %+<5dv|\*(Aq);
\&      => |Day:    +4|
\&
\&   $delta\->printf(\*(Aq|Day: %>5sv|\*(Aq);
\&      => |Day: 7    |
.Ve
.IP "\fBDirectives to print out several fields in terms of one of them\fR" 4
.IX Item "Directives to print out several fields in terms of one of them"
The following directive is used to print out the value of several
different fields, expressed in terms of a single field.
.Sp
.Vb 1
\&   % [+] [pad] [width] [.precision] XYZ
.Ve
.Sp
Here, X, Y, and Z are each one of (y,M,w,d,h,m,s). The directive will
print out the value for fields Y through Z expressed in terms of field X.
.Sp
Y must come before Z in the sequence (y,M,w,d,h,m,s) or it can be the
same as Z.
.Sp
So, to print the day and hour fields in terms of seconds, use the directive:
.Sp
.Vb 1
\&   %sdh
.Ve
.Sp
Any time all of X, Y, and Z are from a single set of fields, exact
relationships are used.
.Sp
If the X, Y, and Z fields do not all belong to the same set of fields,
approximate relationships are used.
.Sp
For non-business deltas, an approximate relationship is needed to link
the Y/M part of the delta to the W/D part and a semi-approximate
relationship is needed to link the W/D part with the H/MN/S part.
These relationships are:
.Sp
.Vb 2
\&   1 day    = 24 hours
\&   1 year   = 365.2425
.Ve
.Sp
For business deltas, the approximate and semi-approximate relationships
used to link the fields together are:
.Sp
.Vb 2
\&   1 week   = X    (length of business week in days)
\&   1 year   = X/7 * 365.2425
.Ve
.Sp
For business deltas, the length of the day is defined using
WorkDayStart and WorkDayEnd.  For non-business deltas, a day is 24
hours long (i.e. daylight saving time is ignored).
.Sp
If 'precision' is included, it is the number of decimal places to
print. If it is not included, but 'width' is included, precision will
be set automatically to display the maximum number of decimal places
given 'width'.
.Sp
If 'pad' is included, it may be the character '<', '>', or '0', and is
used in the same way as printing out a single field.
.Sp
In the following examples, \f(CW$delta\fR contains the delta: 1:2:3:4:5:6:7
.Sp
.Vb 4
\&   $delta\->printf(\*(Aq|%.4Myw|\*(Aq);
\&      => |14.6900|
\&      1 year, 2 months, 3 weeks is approximately
\&      14.6900 months
.Ve
.IP "\fBDirectives to print out portions of the delta\fR" 4
.IX Item "Directives to print out portions of the delta"
The following directives may be used to print out some or all of a delta.
.Sp
.Vb 2
\&   % [+] [pad] [width] Dt
\&   % [+] [pad] [width] DXY
.Ve
.Sp
The first directive will print out the entire delta.
.Sp
The second will print out the delta from the X to Y fields inclusive
(where X and Y are each one of (y,M,w,d,h,m,s) and X must come before
Y in the sequence).
.Sp
\&'pad' is optional and can be either '<' or '>' meaning to pad on the
left or right with spaces. It defaults to '<'.
.Sp
If a '+' is included immediately following the '%', every field will
have a sign attached. Otherwise, only the leftmost field in each set
of fields will include a sign.
.Sp
.Vb 2
\&    $delta\->printf(\*(Aq|%Dt|\*(Aq);
\&       => |+1:2:+3:+4:5:6:7|
\&
\&    $delta\->printf(\*(Aq|%+Dyd|\*(Aq);
\&       => |+1:+2:+3:+4|
.Ve
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer to the Date::Manip::Problems documentation for
information on submitting bug reports or questions to the author.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
